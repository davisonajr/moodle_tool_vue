{"version":3,"file":"vue2-router.min.js","sources":["../src/vue2-router.js"],"sourcesContent":["/*!\n  * vue-router v3.6.5\n  * (c) 2022 Evan You\n  * @license MIT\n  */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.VueRouter = factory());\n  })(this, (function () { 'use strict';\n  \n    /*  */\n  \n    function assert (condition, message) {\n      if (!condition) {\n        throw new Error((\"[vue-router] \" + message))\n      }\n    }\n  \n    function warn (condition, message) {\n      if (!condition) {\n        typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n      }\n    }\n  \n    function extend (a, b) {\n      for (var key in b) {\n        a[key] = b[key];\n      }\n      return a\n    }\n  \n    /*  */\n  \n    var encodeReserveRE = /[!'()*]/g;\n    var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\n    var commaRE = /%2C/g;\n  \n    // fixed encodeURIComponent which is more conformant to RFC3986:\n    // - escapes [!'()*]\n    // - preserve commas\n    var encode = function (str) { return encodeURIComponent(str)\n        .replace(encodeReserveRE, encodeReserveReplacer)\n        .replace(commaRE, ','); };\n  \n    function decode (str) {\n      try {\n        return decodeURIComponent(str)\n      } catch (err) {\n        {\n          warn(false, (\"Error decoding \\\"\" + str + \"\\\". Leaving it intact.\"));\n        }\n      }\n      return str\n    }\n  \n    function resolveQuery (\n      query,\n      extraQuery,\n      _parseQuery\n    ) {\n      if ( extraQuery === void 0 ) extraQuery = {};\n  \n      var parse = _parseQuery || parseQuery;\n      var parsedQuery;\n      try {\n        parsedQuery = parse(query || '');\n      } catch (e) {\n        warn(false, e.message);\n        parsedQuery = {};\n      }\n      for (var key in extraQuery) {\n        var value = extraQuery[key];\n        parsedQuery[key] = Array.isArray(value)\n          ? value.map(castQueryParamValue)\n          : castQueryParamValue(value);\n      }\n      return parsedQuery\n    }\n  \n    var castQueryParamValue = function (value) { return (value == null || typeof value === 'object' ? value : String(value)); };\n  \n    function parseQuery (query) {\n      var res = {};\n  \n      query = query.trim().replace(/^(\\?|#|&)/, '');\n  \n      if (!query) {\n        return res\n      }\n  \n      query.split('&').forEach(function (param) {\n        var parts = param.replace(/\\+/g, ' ').split('=');\n        var key = decode(parts.shift());\n        var val = parts.length > 0 ? decode(parts.join('=')) : null;\n  \n        if (res[key] === undefined) {\n          res[key] = val;\n        } else if (Array.isArray(res[key])) {\n          res[key].push(val);\n        } else {\n          res[key] = [res[key], val];\n        }\n      });\n  \n      return res\n    }\n  \n    function stringifyQuery (obj) {\n      var res = obj\n        ? Object.keys(obj)\n          .map(function (key) {\n            var val = obj[key];\n  \n            if (val === undefined) {\n              return ''\n            }\n  \n            if (val === null) {\n              return encode(key)\n            }\n  \n            if (Array.isArray(val)) {\n              var result = [];\n              val.forEach(function (val2) {\n                if (val2 === undefined) {\n                  return\n                }\n                if (val2 === null) {\n                  result.push(encode(key));\n                } else {\n                  result.push(encode(key) + '=' + encode(val2));\n                }\n              });\n              return result.join('&')\n            }\n  \n            return encode(key) + '=' + encode(val)\n          })\n          .filter(function (x) { return x.length > 0; })\n          .join('&')\n        : null;\n      return res ? (\"?\" + res) : ''\n    }\n  \n    /*  */\n  \n    var trailingSlashRE = /\\/?$/;\n  \n    function createRoute (\n      record,\n      location,\n      redirectedFrom,\n      router\n    ) {\n      var stringifyQuery = router && router.options.stringifyQuery;\n  \n      var query = location.query || {};\n      try {\n        query = clone(query);\n      } catch (e) {}\n  \n      var route = {\n        name: location.name || (record && record.name),\n        meta: (record && record.meta) || {},\n        path: location.path || '/',\n        hash: location.hash || '',\n        query: query,\n        params: location.params || {},\n        fullPath: getFullPath(location, stringifyQuery),\n        matched: record ? formatMatch(record) : []\n      };\n      if (redirectedFrom) {\n        route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);\n      }\n      return Object.freeze(route)\n    }\n  \n    function clone (value) {\n      if (Array.isArray(value)) {\n        return value.map(clone)\n      } else if (value && typeof value === 'object') {\n        var res = {};\n        for (var key in value) {\n          res[key] = clone(value[key]);\n        }\n        return res\n      } else {\n        return value\n      }\n    }\n  \n    // the starting route that represents the initial state\n    var START = createRoute(null, {\n      path: '/'\n    });\n  \n    function formatMatch (record) {\n      var res = [];\n      while (record) {\n        res.unshift(record);\n        record = record.parent;\n      }\n      return res\n    }\n  \n    function getFullPath (\n      ref,\n      _stringifyQuery\n    ) {\n      var path = ref.path;\n      var query = ref.query; if ( query === void 0 ) query = {};\n      var hash = ref.hash; if ( hash === void 0 ) hash = '';\n  \n      var stringify = _stringifyQuery || stringifyQuery;\n      return (path || '/') + stringify(query) + hash\n    }\n  \n    function isSameRoute (a, b, onlyPath) {\n      if (b === START) {\n        return a === b\n      } else if (!b) {\n        return false\n      } else if (a.path && b.path) {\n        return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && (onlyPath ||\n          a.hash === b.hash &&\n          isObjectEqual(a.query, b.query))\n      } else if (a.name && b.name) {\n        return (\n          a.name === b.name &&\n          (onlyPath || (\n            a.hash === b.hash &&\n          isObjectEqual(a.query, b.query) &&\n          isObjectEqual(a.params, b.params))\n          )\n        )\n      } else {\n        return false\n      }\n    }\n  \n    function isObjectEqual (a, b) {\n      if ( a === void 0 ) a = {};\n      if ( b === void 0 ) b = {};\n  \n      // handle null value #1566\n      if (!a || !b) { return a === b }\n      var aKeys = Object.keys(a).sort();\n      var bKeys = Object.keys(b).sort();\n      if (aKeys.length !== bKeys.length) {\n        return false\n      }\n      return aKeys.every(function (key, i) {\n        var aVal = a[key];\n        var bKey = bKeys[i];\n        if (bKey !== key) { return false }\n        var bVal = b[key];\n        // query values can be null and undefined\n        if (aVal == null || bVal == null) { return aVal === bVal }\n        // check nested equality\n        if (typeof aVal === 'object' && typeof bVal === 'object') {\n          return isObjectEqual(aVal, bVal)\n        }\n        return String(aVal) === String(bVal)\n      })\n    }\n  \n    function isIncludedRoute (current, target) {\n      return (\n        current.path.replace(trailingSlashRE, '/').indexOf(\n          target.path.replace(trailingSlashRE, '/')\n        ) === 0 &&\n        (!target.hash || current.hash === target.hash) &&\n        queryIncludes(current.query, target.query)\n      )\n    }\n  \n    function queryIncludes (current, target) {\n      for (var key in target) {\n        if (!(key in current)) {\n          return false\n        }\n      }\n      return true\n    }\n  \n    function handleRouteEntered (route) {\n      for (var i = 0; i < route.matched.length; i++) {\n        var record = route.matched[i];\n        for (var name in record.instances) {\n          var instance = record.instances[name];\n          var cbs = record.enteredCbs[name];\n          if (!instance || !cbs) { continue }\n          delete record.enteredCbs[name];\n          for (var i$1 = 0; i$1 < cbs.length; i$1++) {\n            if (!instance._isBeingDestroyed) { cbs[i$1](instance); }\n          }\n        }\n      }\n    }\n  \n    var View = {\n      name: 'RouterView',\n      functional: true,\n      props: {\n        name: {\n          type: String,\n          default: 'default'\n        }\n      },\n      render: function render (_, ref) {\n        var props = ref.props;\n        var children = ref.children;\n        var parent = ref.parent;\n        var data = ref.data;\n  \n        // used by devtools to display a router-view badge\n        data.routerView = true;\n  \n        // directly use parent context's createElement() function\n        // so that components rendered by router-view can resolve named slots\n        var h = parent.$createElement;\n        var name = props.name;\n        var route = parent.$route;\n        var cache = parent._routerViewCache || (parent._routerViewCache = {});\n  \n        // determine current view depth, also check to see if the tree\n        // has been toggled inactive but kept-alive.\n        var depth = 0;\n        var inactive = false;\n        while (parent && parent._routerRoot !== parent) {\n          var vnodeData = parent.$vnode ? parent.$vnode.data : {};\n          if (vnodeData.routerView) {\n            depth++;\n          }\n          if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {\n            inactive = true;\n          }\n          parent = parent.$parent;\n        }\n        data.routerViewDepth = depth;\n  \n        // render previous view if the tree is inactive and kept-alive\n        if (inactive) {\n          var cachedData = cache[name];\n          var cachedComponent = cachedData && cachedData.component;\n          if (cachedComponent) {\n            // #2301\n            // pass props\n            if (cachedData.configProps) {\n              fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);\n            }\n            return h(cachedComponent, data, children)\n          } else {\n            // render previous empty view\n            return h()\n          }\n        }\n  \n        var matched = route.matched[depth];\n        var component = matched && matched.components[name];\n  \n        // render empty node if no matched route or no config component\n        if (!matched || !component) {\n          cache[name] = null;\n          return h()\n        }\n  \n        // cache component\n        cache[name] = { component: component };\n  \n        // attach instance registration hook\n        // this will be called in the instance's injected lifecycle hooks\n        data.registerRouteInstance = function (vm, val) {\n          // val could be undefined for unregistration\n          var current = matched.instances[name];\n          if (\n            (val && current !== vm) ||\n            (!val && current === vm)\n          ) {\n            matched.instances[name] = val;\n          }\n        }\n  \n        // also register instance in prepatch hook\n        // in case the same component instance is reused across different routes\n        ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n          matched.instances[name] = vnode.componentInstance;\n        };\n  \n        // register instance in init hook\n        // in case kept-alive component be actived when routes changed\n        data.hook.init = function (vnode) {\n          if (vnode.data.keepAlive &&\n            vnode.componentInstance &&\n            vnode.componentInstance !== matched.instances[name]\n          ) {\n            matched.instances[name] = vnode.componentInstance;\n          }\n  \n          // if the route transition has already been confirmed then we weren't\n          // able to call the cbs during confirmation as the component was not\n          // registered yet, so we call it here.\n          handleRouteEntered(route);\n        };\n  \n        var configProps = matched.props && matched.props[name];\n        // save route and configProps in cache\n        if (configProps) {\n          extend(cache[name], {\n            route: route,\n            configProps: configProps\n          });\n          fillPropsinData(component, data, route, configProps);\n        }\n  \n        return h(component, data, children)\n      }\n    };\n  \n    function fillPropsinData (component, data, route, configProps) {\n      // resolve props\n      var propsToPass = data.props = resolveProps(route, configProps);\n      if (propsToPass) {\n        // clone to prevent mutation\n        propsToPass = data.props = extend({}, propsToPass);\n        // pass non-declared props as attrs\n        var attrs = data.attrs = data.attrs || {};\n        for (var key in propsToPass) {\n          if (!component.props || !(key in component.props)) {\n            attrs[key] = propsToPass[key];\n            delete propsToPass[key];\n          }\n        }\n      }\n    }\n  \n    function resolveProps (route, config) {\n      switch (typeof config) {\n        case 'undefined':\n          return\n        case 'object':\n          return config\n        case 'function':\n          return config(route)\n        case 'boolean':\n          return config ? route.params : undefined\n        default:\n          {\n            warn(\n              false,\n              \"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", \" +\n              \"expecting an object, function or boolean.\"\n            );\n          }\n      }\n    }\n  \n    /*  */\n  \n    function resolvePath (\n      relative,\n      base,\n      append\n    ) {\n      var firstChar = relative.charAt(0);\n      if (firstChar === '/') {\n        return relative\n      }\n  \n      if (firstChar === '?' || firstChar === '#') {\n        return base + relative\n      }\n  \n      var stack = base.split('/');\n  \n      // remove trailing segment if:\n      // - not appending\n      // - appending to trailing slash (last segment is empty)\n      if (!append || !stack[stack.length - 1]) {\n        stack.pop();\n      }\n  \n      // resolve relative path\n      var segments = relative.replace(/^\\//, '').split('/');\n      for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        if (segment === '..') {\n          stack.pop();\n        } else if (segment !== '.') {\n          stack.push(segment);\n        }\n      }\n  \n      // ensure leading slash\n      if (stack[0] !== '') {\n        stack.unshift('');\n      }\n  \n      return stack.join('/')\n    }\n  \n    function parsePath (path) {\n      var hash = '';\n      var query = '';\n  \n      var hashIndex = path.indexOf('#');\n      if (hashIndex >= 0) {\n        hash = path.slice(hashIndex);\n        path = path.slice(0, hashIndex);\n      }\n  \n      var queryIndex = path.indexOf('?');\n      if (queryIndex >= 0) {\n        query = path.slice(queryIndex + 1);\n        path = path.slice(0, queryIndex);\n      }\n  \n      return {\n        path: path,\n        query: query,\n        hash: hash\n      }\n    }\n  \n    function cleanPath (path) {\n      return path.replace(/\\/(?:\\s*\\/)+/g, '/')\n    }\n  \n    var isarray = Array.isArray || function (arr) {\n      return Object.prototype.toString.call(arr) == '[object Array]';\n    };\n  \n    /**\n     * Expose `pathToRegexp`.\n     */\n    var pathToRegexp_1 = pathToRegexp;\n    var parse_1 = parse;\n    var compile_1 = compile;\n    var tokensToFunction_1 = tokensToFunction;\n    var tokensToRegExp_1 = tokensToRegExp;\n  \n    /**\n     * The main path matching regexp utility.\n     *\n     * @type {RegExp}\n     */\n    var PATH_REGEXP = new RegExp([\n      // Match escaped characters that would otherwise appear in future matches.\n      // This allows the user to escape special characters that won't transform.\n      '(\\\\\\\\.)',\n      // Match Express-style parameters and un-named parameters with a prefix\n      // and optional suffixes. Matches appear as:\n      //\n      // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n      // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n      // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n      '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n    ].join('|'), 'g');\n  \n    /**\n     * Parse a string for the raw tokens.\n     *\n     * @param  {string}  str\n     * @param  {Object=} options\n     * @return {!Array}\n     */\n    function parse (str, options) {\n      var tokens = [];\n      var key = 0;\n      var index = 0;\n      var path = '';\n      var defaultDelimiter = options && options.delimiter || '/';\n      var res;\n  \n      while ((res = PATH_REGEXP.exec(str)) != null) {\n        var m = res[0];\n        var escaped = res[1];\n        var offset = res.index;\n        path += str.slice(index, offset);\n        index = offset + m.length;\n  \n        // Ignore already escaped sequences.\n        if (escaped) {\n          path += escaped[1];\n          continue\n        }\n  \n        var next = str[index];\n        var prefix = res[2];\n        var name = res[3];\n        var capture = res[4];\n        var group = res[5];\n        var modifier = res[6];\n        var asterisk = res[7];\n  \n        // Push the current path onto the tokens.\n        if (path) {\n          tokens.push(path);\n          path = '';\n        }\n  \n        var partial = prefix != null && next != null && next !== prefix;\n        var repeat = modifier === '+' || modifier === '*';\n        var optional = modifier === '?' || modifier === '*';\n        var delimiter = res[2] || defaultDelimiter;\n        var pattern = capture || group;\n  \n        tokens.push({\n          name: name || key++,\n          prefix: prefix || '',\n          delimiter: delimiter,\n          optional: optional,\n          repeat: repeat,\n          partial: partial,\n          asterisk: !!asterisk,\n          pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n        });\n      }\n  \n      // Match any characters still remaining.\n      if (index < str.length) {\n        path += str.substr(index);\n      }\n  \n      // If the path exists, push it onto the end.\n      if (path) {\n        tokens.push(path);\n      }\n  \n      return tokens\n    }\n  \n    /**\n     * Compile a string to a template function for the path.\n     *\n     * @param  {string}             str\n     * @param  {Object=}            options\n     * @return {!function(Object=, Object=)}\n     */\n    function compile (str, options) {\n      return tokensToFunction(parse(str, options), options)\n    }\n  \n    /**\n     * Prettier encoding of URI path segments.\n     *\n     * @param  {string}\n     * @return {string}\n     */\n    function encodeURIComponentPretty (str) {\n      return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n      })\n    }\n  \n    /**\n     * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n     *\n     * @param  {string}\n     * @return {string}\n     */\n    function encodeAsterisk (str) {\n      return encodeURI(str).replace(/[?#]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n      })\n    }\n  \n    /**\n     * Expose a method for transforming tokens into the path function.\n     */\n    function tokensToFunction (tokens, options) {\n      // Compile all the tokens into regexps.\n      var matches = new Array(tokens.length);\n  \n      // Compile all the patterns before compilation.\n      for (var i = 0; i < tokens.length; i++) {\n        if (typeof tokens[i] === 'object') {\n          matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));\n        }\n      }\n  \n      return function (obj, opts) {\n        var path = '';\n        var data = obj || {};\n        var options = opts || {};\n        var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n  \n        for (var i = 0; i < tokens.length; i++) {\n          var token = tokens[i];\n  \n          if (typeof token === 'string') {\n            path += token;\n  \n            continue\n          }\n  \n          var value = data[token.name];\n          var segment;\n  \n          if (value == null) {\n            if (token.optional) {\n              // Prepend partial segment prefixes.\n              if (token.partial) {\n                path += token.prefix;\n              }\n  \n              continue\n            } else {\n              throw new TypeError('Expected \"' + token.name + '\" to be defined')\n            }\n          }\n  \n          if (isarray(value)) {\n            if (!token.repeat) {\n              throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n            }\n  \n            if (value.length === 0) {\n              if (token.optional) {\n                continue\n              } else {\n                throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n              }\n            }\n  \n            for (var j = 0; j < value.length; j++) {\n              segment = encode(value[j]);\n  \n              if (!matches[i].test(segment)) {\n                throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n              }\n  \n              path += (j === 0 ? token.prefix : token.delimiter) + segment;\n            }\n  \n            continue\n          }\n  \n          segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n  \n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n  \n          path += token.prefix + segment;\n        }\n  \n        return path\n      }\n    }\n  \n    /**\n     * Escape a regular expression string.\n     *\n     * @param  {string} str\n     * @return {string}\n     */\n    function escapeString (str) {\n      return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n    }\n  \n    /**\n     * Escape the capturing group by escaping special characters and meaning.\n     *\n     * @param  {string} group\n     * @return {string}\n     */\n    function escapeGroup (group) {\n      return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n    }\n  \n    /**\n     * Attach the keys as a property of the regexp.\n     *\n     * @param  {!RegExp} re\n     * @param  {Array}   keys\n     * @return {!RegExp}\n     */\n    function attachKeys (re, keys) {\n      re.keys = keys;\n      return re\n    }\n  \n    /**\n     * Get the flags for a regexp from the options.\n     *\n     * @param  {Object} options\n     * @return {string}\n     */\n    function flags (options) {\n      return options && options.sensitive ? '' : 'i'\n    }\n  \n    /**\n     * Pull out keys from a regexp.\n     *\n     * @param  {!RegExp} path\n     * @param  {!Array}  keys\n     * @return {!RegExp}\n     */\n    function regexpToRegexp (path, keys) {\n      // Use a negative lookahead to match only capturing groups.\n      var groups = path.source.match(/\\((?!\\?)/g);\n  \n      if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n          keys.push({\n            name: i,\n            prefix: null,\n            delimiter: null,\n            optional: false,\n            repeat: false,\n            partial: false,\n            asterisk: false,\n            pattern: null\n          });\n        }\n      }\n  \n      return attachKeys(path, keys)\n    }\n  \n    /**\n     * Transform an array into a regexp.\n     *\n     * @param  {!Array}  path\n     * @param  {Array}   keys\n     * @param  {!Object} options\n     * @return {!RegExp}\n     */\n    function arrayToRegexp (path, keys, options) {\n      var parts = [];\n  \n      for (var i = 0; i < path.length; i++) {\n        parts.push(pathToRegexp(path[i], keys, options).source);\n      }\n  \n      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  \n      return attachKeys(regexp, keys)\n    }\n  \n    /**\n     * Create a path regexp from string input.\n     *\n     * @param  {string}  path\n     * @param  {!Array}  keys\n     * @param  {!Object} options\n     * @return {!RegExp}\n     */\n    function stringToRegexp (path, keys, options) {\n      return tokensToRegExp(parse(path, options), keys, options)\n    }\n  \n    /**\n     * Expose a function for taking tokens and returning a RegExp.\n     *\n     * @param  {!Array}          tokens\n     * @param  {(Array|Object)=} keys\n     * @param  {Object=}         options\n     * @return {!RegExp}\n     */\n    function tokensToRegExp (tokens, keys, options) {\n      if (!isarray(keys)) {\n        options = /** @type {!Object} */ (keys || options);\n        keys = [];\n      }\n  \n      options = options || {};\n  \n      var strict = options.strict;\n      var end = options.end !== false;\n      var route = '';\n  \n      // Iterate over the tokens and create our regexp string.\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n  \n        if (typeof token === 'string') {\n          route += escapeString(token);\n        } else {\n          var prefix = escapeString(token.prefix);\n          var capture = '(?:' + token.pattern + ')';\n  \n          keys.push(token);\n  \n          if (token.repeat) {\n            capture += '(?:' + prefix + capture + ')*';\n          }\n  \n          if (token.optional) {\n            if (!token.partial) {\n              capture = '(?:' + prefix + '(' + capture + '))?';\n            } else {\n              capture = prefix + '(' + capture + ')?';\n            }\n          } else {\n            capture = prefix + '(' + capture + ')';\n          }\n  \n          route += capture;\n        }\n      }\n  \n      var delimiter = escapeString(options.delimiter || '/');\n      var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n  \n      // In non-strict mode we allow a slash at the end of match. If the path to\n      // match already ends with a slash, we remove it for consistency. The slash\n      // is valid at the end of a path match, not in the middle. This is important\n      // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n      if (!strict) {\n        route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n      }\n  \n      if (end) {\n        route += '$';\n      } else {\n        // In non-ending mode, we need the capturing groups to match as much as\n        // possible by using a positive lookahead to the end or next path segment.\n        route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n      }\n  \n      return attachKeys(new RegExp('^' + route, flags(options)), keys)\n    }\n  \n    /**\n     * Normalize the given path string, returning a regular expression.\n     *\n     * An empty array can be passed in for the keys, which will hold the\n     * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n     *\n     * @param  {(string|RegExp|Array)} path\n     * @param  {(Array|Object)=}       keys\n     * @param  {Object=}               options\n     * @return {!RegExp}\n     */\n    function pathToRegexp (path, keys, options) {\n      if (!isarray(keys)) {\n        options = /** @type {!Object} */ (keys || options);\n        keys = [];\n      }\n  \n      options = options || {};\n  \n      if (path instanceof RegExp) {\n        return regexpToRegexp(path, /** @type {!Array} */ (keys))\n      }\n  \n      if (isarray(path)) {\n        return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n      }\n  \n      return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n    }\n    pathToRegexp_1.parse = parse_1;\n    pathToRegexp_1.compile = compile_1;\n    pathToRegexp_1.tokensToFunction = tokensToFunction_1;\n    pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n  \n    /*  */\n  \n    // $flow-disable-line\n    var regexpCompileCache = Object.create(null);\n  \n    function fillParams (\n      path,\n      params,\n      routeMsg\n    ) {\n      params = params || {};\n      try {\n        var filler =\n          regexpCompileCache[path] ||\n          (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n  \n        // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}\n        // and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string\n        if (typeof params.pathMatch === 'string') { params[0] = params.pathMatch; }\n  \n        return filler(params, { pretty: true })\n      } catch (e) {\n        {\n          // Fix #3072 no warn if `pathMatch` is string\n          warn(typeof params.pathMatch === 'string', (\"missing param for \" + routeMsg + \": \" + (e.message)));\n        }\n        return ''\n      } finally {\n        // delete the 0 if it was added\n        delete params[0];\n      }\n    }\n  \n    /*  */\n  \n    function normalizeLocation (\n      raw,\n      current,\n      append,\n      router\n    ) {\n      var next = typeof raw === 'string' ? { path: raw } : raw;\n      // named target\n      if (next._normalized) {\n        return next\n      } else if (next.name) {\n        next = extend({}, raw);\n        var params = next.params;\n        if (params && typeof params === 'object') {\n          next.params = extend({}, params);\n        }\n        return next\n      }\n  \n      // relative params\n      if (!next.path && next.params && current) {\n        next = extend({}, next);\n        next._normalized = true;\n        var params$1 = extend(extend({}, current.params), next.params);\n        if (current.name) {\n          next.name = current.name;\n          next.params = params$1;\n        } else if (current.matched.length) {\n          var rawPath = current.matched[current.matched.length - 1].path;\n          next.path = fillParams(rawPath, params$1, (\"path \" + (current.path)));\n        } else {\n          warn(false, \"relative params navigation requires a current route.\");\n        }\n        return next\n      }\n  \n      var parsedPath = parsePath(next.path || '');\n      var basePath = (current && current.path) || '/';\n      var path = parsedPath.path\n        ? resolvePath(parsedPath.path, basePath, append || next.append)\n        : basePath;\n  \n      var query = resolveQuery(\n        parsedPath.query,\n        next.query,\n        router && router.options.parseQuery\n      );\n  \n      var hash = next.hash || parsedPath.hash;\n      if (hash && hash.charAt(0) !== '#') {\n        hash = \"#\" + hash;\n      }\n  \n      return {\n        _normalized: true,\n        path: path,\n        query: query,\n        hash: hash\n      }\n    }\n  \n    /*  */\n  \n    // work around weird flow bug\n    var toTypes = [String, Object];\n    var eventTypes = [String, Array];\n  \n    var noop = function () {};\n  \n    var warnedCustomSlot;\n    var warnedTagProp;\n    var warnedEventProp;\n  \n    var Link = {\n      name: 'RouterLink',\n      props: {\n        to: {\n          type: toTypes,\n          required: true\n        },\n        tag: {\n          type: String,\n          default: 'a'\n        },\n        custom: Boolean,\n        exact: Boolean,\n        exactPath: Boolean,\n        append: Boolean,\n        replace: Boolean,\n        activeClass: String,\n        exactActiveClass: String,\n        ariaCurrentValue: {\n          type: String,\n          default: 'page'\n        },\n        event: {\n          type: eventTypes,\n          default: 'click'\n        }\n      },\n      render: function render (h) {\n        var this$1$1 = this;\n  \n        var router = this.$router;\n        var current = this.$route;\n        var ref = router.resolve(\n          this.to,\n          current,\n          this.append\n        );\n        var location = ref.location;\n        var route = ref.route;\n        var href = ref.href;\n  \n        var classes = {};\n        var globalActiveClass = router.options.linkActiveClass;\n        var globalExactActiveClass = router.options.linkExactActiveClass;\n        // Support global empty active class\n        var activeClassFallback =\n          globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n        var exactActiveClassFallback =\n          globalExactActiveClass == null\n            ? 'router-link-exact-active'\n            : globalExactActiveClass;\n        var activeClass =\n          this.activeClass == null ? activeClassFallback : this.activeClass;\n        var exactActiveClass =\n          this.exactActiveClass == null\n            ? exactActiveClassFallback\n            : this.exactActiveClass;\n  \n        var compareTarget = route.redirectedFrom\n          ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)\n          : route;\n  \n        classes[exactActiveClass] = isSameRoute(current, compareTarget, this.exactPath);\n        classes[activeClass] = this.exact || this.exactPath\n          ? classes[exactActiveClass]\n          : isIncludedRoute(current, compareTarget);\n  \n        var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;\n  \n        var handler = function (e) {\n          if (guardEvent(e)) {\n            if (this$1$1.replace) {\n              router.replace(location, noop);\n            } else {\n              router.push(location, noop);\n            }\n          }\n        };\n  \n        var on = { click: guardEvent };\n        if (Array.isArray(this.event)) {\n          this.event.forEach(function (e) {\n            on[e] = handler;\n          });\n        } else {\n          on[this.event] = handler;\n        }\n  \n        var data = { class: classes };\n  \n        var scopedSlot =\n          !this.$scopedSlots.$hasNormal &&\n          this.$scopedSlots.default &&\n          this.$scopedSlots.default({\n            href: href,\n            route: route,\n            navigate: handler,\n            isActive: classes[activeClass],\n            isExactActive: classes[exactActiveClass]\n          });\n  \n        if (scopedSlot) {\n          if (!this.custom) {\n            !warnedCustomSlot && warn(false, 'In Vue Router 4, the v-slot API will by default wrap its content with an <a> element. Use the custom prop to remove this warning:\\n<router-link v-slot=\"{ navigate, href }\" custom></router-link>\\n');\n            warnedCustomSlot = true;\n          }\n          if (scopedSlot.length === 1) {\n            return scopedSlot[0]\n          } else if (scopedSlot.length > 1 || !scopedSlot.length) {\n            {\n              warn(\n                false,\n                (\"<router-link> with to=\\\"\" + (this.to) + \"\\\" is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.\")\n              );\n            }\n            return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)\n          }\n        }\n  \n        {\n          if ('tag' in this.$options.propsData && !warnedTagProp) {\n            warn(\n              false,\n              \"<router-link>'s tag prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.\"\n            );\n            warnedTagProp = true;\n          }\n          if ('event' in this.$options.propsData && !warnedEventProp) {\n            warn(\n              false,\n              \"<router-link>'s event prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.\"\n            );\n            warnedEventProp = true;\n          }\n        }\n  \n        if (this.tag === 'a') {\n          data.on = on;\n          data.attrs = { href: href, 'aria-current': ariaCurrentValue };\n        } else {\n          // find the first <a> child and apply listener and href\n          var a = findAnchor(this.$slots.default);\n          if (a) {\n            // in case the <a> is a static node\n            a.isStatic = false;\n            var aData = (a.data = extend({}, a.data));\n            aData.on = aData.on || {};\n            // transform existing events in both objects into arrays so we can push later\n            for (var event in aData.on) {\n              var handler$1 = aData.on[event];\n              if (event in on) {\n                aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];\n              }\n            }\n            // append new listeners for router-link\n            for (var event$1 in on) {\n              if (event$1 in aData.on) {\n                // on[event] is always a function\n                aData.on[event$1].push(on[event$1]);\n              } else {\n                aData.on[event$1] = handler;\n              }\n            }\n  \n            var aAttrs = (a.data.attrs = extend({}, a.data.attrs));\n            aAttrs.href = href;\n            aAttrs['aria-current'] = ariaCurrentValue;\n          } else {\n            // doesn't have <a> child, apply listener to self\n            data.on = on;\n          }\n        }\n  \n        return h(this.tag, data, this.$slots.default)\n      }\n    };\n  \n    function guardEvent (e) {\n      // don't redirect with control keys\n      if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\n      // don't redirect when preventDefault called\n      if (e.defaultPrevented) { return }\n      // don't redirect on right click\n      if (e.button !== undefined && e.button !== 0) { return }\n      // don't redirect if `target=\"_blank\"`\n      if (e.currentTarget && e.currentTarget.getAttribute) {\n        var target = e.currentTarget.getAttribute('target');\n        if (/\\b_blank\\b/i.test(target)) { return }\n      }\n      // this may be a Weex event which doesn't have this method\n      if (e.preventDefault) {\n        e.preventDefault();\n      }\n      return true\n    }\n  \n    function findAnchor (children) {\n      if (children) {\n        var child;\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          if (child.tag === 'a') {\n            return child\n          }\n          if (child.children && (child = findAnchor(child.children))) {\n            return child\n          }\n        }\n      }\n    }\n  \n    var _Vue;\n  \n    function install (Vue) {\n      if (install.installed && _Vue === Vue) { return }\n      install.installed = true;\n  \n      _Vue = Vue;\n  \n      var isDef = function (v) { return v !== undefined; };\n  \n      var registerInstance = function (vm, callVal) {\n        var i = vm.$options._parentVnode;\n        if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n          i(vm, callVal);\n        }\n      };\n  \n      Vue.mixin({\n        beforeCreate: function beforeCreate () {\n          if (isDef(this.$options.router)) {\n            this._routerRoot = this;\n            this._router = this.$options.router;\n            this._router.init(this);\n            Vue.util.defineReactive(this, '_route', this._router.history.current);\n          } else {\n            this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n          }\n          registerInstance(this, this);\n        },\n        destroyed: function destroyed () {\n          registerInstance(this);\n        }\n      });\n  \n      Object.defineProperty(Vue.prototype, '$router', {\n        get: function get () { return this._routerRoot._router }\n      });\n  \n      Object.defineProperty(Vue.prototype, '$route', {\n        get: function get () { return this._routerRoot._route }\n      });\n  \n      Vue.component('RouterView', View);\n      Vue.component('RouterLink', Link);\n  \n      var strats = Vue.config.optionMergeStrategies;\n      // use the same hook merging strategy for route hooks\n      strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n    }\n  \n    /*  */\n  \n    var inBrowser = typeof window !== 'undefined';\n  \n    /*  */\n  \n    function createRouteMap (\n      routes,\n      oldPathList,\n      oldPathMap,\n      oldNameMap,\n      parentRoute\n    ) {\n      // the path list is used to control path matching priority\n      var pathList = oldPathList || [];\n      // $flow-disable-line\n      var pathMap = oldPathMap || Object.create(null);\n      // $flow-disable-line\n      var nameMap = oldNameMap || Object.create(null);\n  \n      routes.forEach(function (route) {\n        addRouteRecord(pathList, pathMap, nameMap, route, parentRoute);\n      });\n  \n      // ensure wildcard routes are always at the end\n      for (var i = 0, l = pathList.length; i < l; i++) {\n        if (pathList[i] === '*') {\n          pathList.push(pathList.splice(i, 1)[0]);\n          l--;\n          i--;\n        }\n      }\n  \n      {\n        // warn if routes do not include leading slashes\n        var found = pathList\n        // check for missing leading slash\n          .filter(function (path) { return path && path.charAt(0) !== '*' && path.charAt(0) !== '/'; });\n  \n        if (found.length > 0) {\n          var pathNames = found.map(function (path) { return (\"- \" + path); }).join('\\n');\n          warn(false, (\"Non-nested routes must include a leading slash character. Fix the following routes: \\n\" + pathNames));\n        }\n      }\n  \n      return {\n        pathList: pathList,\n        pathMap: pathMap,\n        nameMap: nameMap\n      }\n    }\n  \n    function addRouteRecord (\n      pathList,\n      pathMap,\n      nameMap,\n      route,\n      parent,\n      matchAs\n    ) {\n      var path = route.path;\n      var name = route.name;\n      {\n        assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n        assert(\n          typeof route.component !== 'string',\n          \"route config \\\"component\\\" for path: \" + (String(\n            path || name\n          )) + \" cannot be a \" + \"string id. Use an actual component instead.\"\n        );\n  \n        warn(\n          // eslint-disable-next-line no-control-regex\n          !/[^\\u0000-\\u007F]+/.test(path),\n          \"Route with path \\\"\" + path + \"\\\" contains unencoded characters, make sure \" +\n            \"your path is correctly encoded before passing it to the router. Use \" +\n            \"encodeURI to encode static segments of your path.\"\n        );\n      }\n  \n      var pathToRegexpOptions =\n        route.pathToRegexpOptions || {};\n      var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);\n  \n      if (typeof route.caseSensitive === 'boolean') {\n        pathToRegexpOptions.sensitive = route.caseSensitive;\n      }\n  \n      var record = {\n        path: normalizedPath,\n        regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n        components: route.components || { default: route.component },\n        alias: route.alias\n          ? typeof route.alias === 'string'\n            ? [route.alias]\n            : route.alias\n          : [],\n        instances: {},\n        enteredCbs: {},\n        name: name,\n        parent: parent,\n        matchAs: matchAs,\n        redirect: route.redirect,\n        beforeEnter: route.beforeEnter,\n        meta: route.meta || {},\n        props:\n          route.props == null\n            ? {}\n            : route.components\n              ? route.props\n              : { default: route.props }\n      };\n  \n      if (route.children) {\n        // Warn if route is named, does not redirect and has a default child route.\n        // If users navigate to this route by name, the default child will\n        // not be rendered (GH Issue #629)\n        {\n          if (\n            route.name &&\n            !route.redirect &&\n            route.children.some(function (child) { return /^\\/?$/.test(child.path); })\n          ) {\n            warn(\n              false,\n              \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n                \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'}\\\"), \" +\n                \"the default child route will not be rendered. Remove the name from \" +\n                \"this route and use the name of the default child route for named \" +\n                \"links instead.\"\n            );\n          }\n        }\n        route.children.forEach(function (child) {\n          var childMatchAs = matchAs\n            ? cleanPath((matchAs + \"/\" + (child.path)))\n            : undefined;\n          addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n        });\n      }\n  \n      if (!pathMap[record.path]) {\n        pathList.push(record.path);\n        pathMap[record.path] = record;\n      }\n  \n      if (route.alias !== undefined) {\n        var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n        for (var i = 0; i < aliases.length; ++i) {\n          var alias = aliases[i];\n          if (alias === path) {\n            warn(\n              false,\n              (\"Found an alias with the same value as the path: \\\"\" + path + \"\\\". You have to remove that alias. It will be ignored in development.\")\n            );\n            // skip in dev to make it work\n            continue\n          }\n  \n          var aliasRoute = {\n            path: alias,\n            children: route.children\n          };\n          addRouteRecord(\n            pathList,\n            pathMap,\n            nameMap,\n            aliasRoute,\n            parent,\n            record.path || '/' // matchAs\n          );\n        }\n      }\n  \n      if (name) {\n        if (!nameMap[name]) {\n          nameMap[name] = record;\n        } else if (!matchAs) {\n          warn(\n            false,\n            \"Duplicate named routes definition: \" +\n              \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n          );\n        }\n      }\n    }\n  \n    function compileRouteRegex (\n      path,\n      pathToRegexpOptions\n    ) {\n      var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n      {\n        var keys = Object.create(null);\n        regex.keys.forEach(function (key) {\n          warn(\n            !keys[key.name],\n            (\"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\")\n          );\n          keys[key.name] = true;\n        });\n      }\n      return regex\n    }\n  \n    function normalizePath (\n      path,\n      parent,\n      strict\n    ) {\n      if (!strict) { path = path.replace(/\\/$/, ''); }\n      if (path[0] === '/') { return path }\n      if (parent == null) { return path }\n      return cleanPath(((parent.path) + \"/\" + path))\n    }\n  \n    /*  */\n  \n  \n  \n    function createMatcher (\n      routes,\n      router\n    ) {\n      var ref = createRouteMap(routes);\n      var pathList = ref.pathList;\n      var pathMap = ref.pathMap;\n      var nameMap = ref.nameMap;\n  \n      function addRoutes (routes) {\n        createRouteMap(routes, pathList, pathMap, nameMap);\n      }\n  \n      function addRoute (parentOrRoute, route) {\n        var parent = (typeof parentOrRoute !== 'object') ? nameMap[parentOrRoute] : undefined;\n        // $flow-disable-line\n        createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent);\n  \n        // add aliases of parent\n        if (parent && parent.alias.length) {\n          createRouteMap(\n            // $flow-disable-line route is defined if parent is\n            parent.alias.map(function (alias) { return ({ path: alias, children: [route] }); }),\n            pathList,\n            pathMap,\n            nameMap,\n            parent\n          );\n        }\n      }\n  \n      function getRoutes () {\n        return pathList.map(function (path) { return pathMap[path]; })\n      }\n  \n      function match (\n        raw,\n        currentRoute,\n        redirectedFrom\n      ) {\n        var location = normalizeLocation(raw, currentRoute, false, router);\n        var name = location.name;\n  \n        if (name) {\n          var record = nameMap[name];\n          {\n            warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n          }\n          if (!record) { return _createRoute(null, location) }\n          var paramNames = record.regex.keys\n            .filter(function (key) { return !key.optional; })\n            .map(function (key) { return key.name; });\n  \n          if (typeof location.params !== 'object') {\n            location.params = {};\n          }\n  \n          if (currentRoute && typeof currentRoute.params === 'object') {\n            for (var key in currentRoute.params) {\n              if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n                location.params[key] = currentRoute.params[key];\n              }\n            }\n          }\n  \n          location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n          return _createRoute(record, location, redirectedFrom)\n        } else if (location.path) {\n          location.params = {};\n          for (var i = 0; i < pathList.length; i++) {\n            var path = pathList[i];\n            var record$1 = pathMap[path];\n            if (matchRoute(record$1.regex, location.path, location.params)) {\n              return _createRoute(record$1, location, redirectedFrom)\n            }\n          }\n        }\n        // no match\n        return _createRoute(null, location)\n      }\n  \n      function redirect (\n        record,\n        location\n      ) {\n        var originalRedirect = record.redirect;\n        var redirect = typeof originalRedirect === 'function'\n          ? originalRedirect(createRoute(record, location, null, router))\n          : originalRedirect;\n  \n        if (typeof redirect === 'string') {\n          redirect = { path: redirect };\n        }\n  \n        if (!redirect || typeof redirect !== 'object') {\n          {\n            warn(\n              false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n            );\n          }\n          return _createRoute(null, location)\n        }\n  \n        var re = redirect;\n        var name = re.name;\n        var path = re.path;\n        var query = location.query;\n        var hash = location.hash;\n        var params = location.params;\n        query = re.hasOwnProperty('query') ? re.query : query;\n        hash = re.hasOwnProperty('hash') ? re.hash : hash;\n        params = re.hasOwnProperty('params') ? re.params : params;\n  \n        if (name) {\n          // resolved named direct\n          var targetRecord = nameMap[name];\n          {\n            assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n          }\n          return match({\n            _normalized: true,\n            name: name,\n            query: query,\n            hash: hash,\n            params: params\n          }, undefined, location)\n        } else if (path) {\n          // 1. resolve relative redirect\n          var rawPath = resolveRecordPath(path, record);\n          // 2. resolve params\n          var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n          // 3. rematch with existing query and hash\n          return match({\n            _normalized: true,\n            path: resolvedPath,\n            query: query,\n            hash: hash\n          }, undefined, location)\n        } else {\n          {\n            warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n          }\n          return _createRoute(null, location)\n        }\n      }\n  \n      function alias (\n        record,\n        location,\n        matchAs\n      ) {\n        var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n        var aliasedMatch = match({\n          _normalized: true,\n          path: aliasedPath\n        });\n        if (aliasedMatch) {\n          var matched = aliasedMatch.matched;\n          var aliasedRecord = matched[matched.length - 1];\n          location.params = aliasedMatch.params;\n          return _createRoute(aliasedRecord, location)\n        }\n        return _createRoute(null, location)\n      }\n  \n      function _createRoute (\n        record,\n        location,\n        redirectedFrom\n      ) {\n        if (record && record.redirect) {\n          return redirect(record, redirectedFrom || location)\n        }\n        if (record && record.matchAs) {\n          return alias(record, location, record.matchAs)\n        }\n        return createRoute(record, location, redirectedFrom, router)\n      }\n  \n      return {\n        match: match,\n        addRoute: addRoute,\n        getRoutes: getRoutes,\n        addRoutes: addRoutes\n      }\n    }\n  \n    function matchRoute (\n      regex,\n      path,\n      params\n    ) {\n      var m = path.match(regex);\n  \n      if (!m) {\n        return false\n      } else if (!params) {\n        return true\n      }\n  \n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = regex.keys[i - 1];\n        if (key) {\n          // Fix #1994: using * with props: true generates a param named 0\n          params[key.name || 'pathMatch'] = typeof m[i] === 'string' ? decode(m[i]) : m[i];\n        }\n      }\n  \n      return true\n    }\n  \n    function resolveRecordPath (path, record) {\n      return resolvePath(path, record.parent ? record.parent.path : '/', true)\n    }\n  \n    /*  */\n  \n    // use User Timing api (if present) for more accurate key precision\n    var Time =\n      inBrowser && window.performance && window.performance.now\n        ? window.performance\n        : Date;\n  \n    function genStateKey () {\n      return Time.now().toFixed(3)\n    }\n  \n    var _key = genStateKey();\n  \n    function getStateKey () {\n      return _key\n    }\n  \n    function setStateKey (key) {\n      return (_key = key)\n    }\n  \n    /*  */\n  \n    var positionStore = Object.create(null);\n  \n    function setupScroll () {\n      // Prevent browser scroll behavior on History popstate\n      if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'manual';\n      }\n      // Fix for #1585 for Firefox\n      // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678\n      // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with\n      // window.location.protocol + '//' + window.location.host\n      // location.host contains the port and location.hostname doesn't\n      var protocolAndPath = window.location.protocol + '//' + window.location.host;\n      var absolutePath = window.location.href.replace(protocolAndPath, '');\n      // preserve existing history state as it could be overriden by the user\n      var stateCopy = extend({}, window.history.state);\n      stateCopy.key = getStateKey();\n      window.history.replaceState(stateCopy, '', absolutePath);\n      window.addEventListener('popstate', handlePopState);\n      return function () {\n        window.removeEventListener('popstate', handlePopState);\n      }\n    }\n  \n    function handleScroll (\n      router,\n      to,\n      from,\n      isPop\n    ) {\n      if (!router.app) {\n        return\n      }\n  \n      var behavior = router.options.scrollBehavior;\n      if (!behavior) {\n        return\n      }\n  \n      {\n        assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n      }\n  \n      // wait until re-render finishes before scrolling\n      router.app.$nextTick(function () {\n        var position = getScrollPosition();\n        var shouldScroll = behavior.call(\n          router,\n          to,\n          from,\n          isPop ? position : null\n        );\n  \n        if (!shouldScroll) {\n          return\n        }\n  \n        if (typeof shouldScroll.then === 'function') {\n          shouldScroll\n            .then(function (shouldScroll) {\n              scrollToPosition((shouldScroll), position);\n            })\n            .catch(function (err) {\n              {\n                assert(false, err.toString());\n              }\n            });\n        } else {\n          scrollToPosition(shouldScroll, position);\n        }\n      });\n    }\n  \n    function saveScrollPosition () {\n      var key = getStateKey();\n      if (key) {\n        positionStore[key] = {\n          x: window.pageXOffset,\n          y: window.pageYOffset\n        };\n      }\n    }\n  \n    function handlePopState (e) {\n      saveScrollPosition();\n      if (e.state && e.state.key) {\n        setStateKey(e.state.key);\n      }\n    }\n  \n    function getScrollPosition () {\n      var key = getStateKey();\n      if (key) {\n        return positionStore[key]\n      }\n    }\n  \n    function getElementPosition (el, offset) {\n      var docEl = document.documentElement;\n      var docRect = docEl.getBoundingClientRect();\n      var elRect = el.getBoundingClientRect();\n      return {\n        x: elRect.left - docRect.left - offset.x,\n        y: elRect.top - docRect.top - offset.y\n      }\n    }\n  \n    function isValidPosition (obj) {\n      return isNumber(obj.x) || isNumber(obj.y)\n    }\n  \n    function normalizePosition (obj) {\n      return {\n        x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n        y: isNumber(obj.y) ? obj.y : window.pageYOffset\n      }\n    }\n  \n    function normalizeOffset (obj) {\n      return {\n        x: isNumber(obj.x) ? obj.x : 0,\n        y: isNumber(obj.y) ? obj.y : 0\n      }\n    }\n  \n    function isNumber (v) {\n      return typeof v === 'number'\n    }\n  \n    var hashStartsWithNumberRE = /^#\\d/;\n  \n    function scrollToPosition (shouldScroll, position) {\n      var isObject = typeof shouldScroll === 'object';\n      if (isObject && typeof shouldScroll.selector === 'string') {\n        // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]\n        // but at the same time, it doesn't make much sense to select an element with an id and an extra selector\n        var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line\n          ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line\n          : document.querySelector(shouldScroll.selector);\n  \n        if (el) {\n          var offset =\n            shouldScroll.offset && typeof shouldScroll.offset === 'object'\n              ? shouldScroll.offset\n              : {};\n          offset = normalizeOffset(offset);\n          position = getElementPosition(el, offset);\n        } else if (isValidPosition(shouldScroll)) {\n          position = normalizePosition(shouldScroll);\n        }\n      } else if (isObject && isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n  \n      if (position) {\n        // $flow-disable-line\n        if ('scrollBehavior' in document.documentElement.style) {\n          window.scrollTo({\n            left: position.x,\n            top: position.y,\n            // $flow-disable-line\n            behavior: shouldScroll.behavior\n          });\n        } else {\n          window.scrollTo(position.x, position.y);\n        }\n      }\n    }\n  \n    /*  */\n  \n    var supportsPushState =\n      inBrowser &&\n      (function () {\n        var ua = window.navigator.userAgent;\n  \n        if (\n          (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n          ua.indexOf('Mobile Safari') !== -1 &&\n          ua.indexOf('Chrome') === -1 &&\n          ua.indexOf('Windows Phone') === -1\n        ) {\n          return false\n        }\n  \n        return window.history && typeof window.history.pushState === 'function'\n      })();\n  \n    function pushState (url, replace) {\n      saveScrollPosition();\n      // try...catch the pushState call to get around Safari\n      // DOM Exception 18 where it limits to 100 pushState calls\n      var history = window.history;\n      try {\n        if (replace) {\n          // preserve existing history state as it could be overriden by the user\n          var stateCopy = extend({}, history.state);\n          stateCopy.key = getStateKey();\n          history.replaceState(stateCopy, '', url);\n        } else {\n          history.pushState({ key: setStateKey(genStateKey()) }, '', url);\n        }\n      } catch (e) {\n        window.location[replace ? 'replace' : 'assign'](url);\n      }\n    }\n  \n    function replaceState (url) {\n      pushState(url, true);\n    }\n  \n    // When changing thing, also edit router.d.ts\n    var NavigationFailureType = {\n      redirected: 2,\n      aborted: 4,\n      cancelled: 8,\n      duplicated: 16\n    };\n  \n    function createNavigationRedirectedError (from, to) {\n      return createRouterError(\n        from,\n        to,\n        NavigationFailureType.redirected,\n        (\"Redirected when going from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (stringifyRoute(\n          to\n        )) + \"\\\" via a navigation guard.\")\n      )\n    }\n  \n    function createNavigationDuplicatedError (from, to) {\n      var error = createRouterError(\n        from,\n        to,\n        NavigationFailureType.duplicated,\n        (\"Avoided redundant navigation to current location: \\\"\" + (from.fullPath) + \"\\\".\")\n      );\n      // backwards compatible with the first introduction of Errors\n      error.name = 'NavigationDuplicated';\n      return error\n    }\n  \n    function createNavigationCancelledError (from, to) {\n      return createRouterError(\n        from,\n        to,\n        NavigationFailureType.cancelled,\n        (\"Navigation cancelled from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (to.fullPath) + \"\\\" with a new navigation.\")\n      )\n    }\n  \n    function createNavigationAbortedError (from, to) {\n      return createRouterError(\n        from,\n        to,\n        NavigationFailureType.aborted,\n        (\"Navigation aborted from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (to.fullPath) + \"\\\" via a navigation guard.\")\n      )\n    }\n  \n    function createRouterError (from, to, type, message) {\n      var error = new Error(message);\n      error._isRouter = true;\n      error.from = from;\n      error.to = to;\n      error.type = type;\n  \n      return error\n    }\n  \n    var propertiesToLog = ['params', 'query', 'hash'];\n  \n    function stringifyRoute (to) {\n      if (typeof to === 'string') { return to }\n      if ('path' in to) { return to.path }\n      var location = {};\n      propertiesToLog.forEach(function (key) {\n        if (key in to) { location[key] = to[key]; }\n      });\n      return JSON.stringify(location, null, 2)\n    }\n  \n    function isError (err) {\n      return Object.prototype.toString.call(err).indexOf('Error') > -1\n    }\n  \n    function isNavigationFailure (err, errorType) {\n      return (\n        isError(err) &&\n        err._isRouter &&\n        (errorType == null || err.type === errorType)\n      )\n    }\n  \n    /*  */\n  \n    function runQueue (queue, fn, cb) {\n      var step = function (index) {\n        if (index >= queue.length) {\n          cb();\n        } else {\n          if (queue[index]) {\n            fn(queue[index], function () {\n              step(index + 1);\n            });\n          } else {\n            step(index + 1);\n          }\n        }\n      };\n      step(0);\n    }\n  \n    /*  */\n  \n    function resolveAsyncComponents (matched) {\n      return function (to, from, next) {\n        var hasAsync = false;\n        var pending = 0;\n        var error = null;\n  \n        flatMapComponents(matched, function (def, _, match, key) {\n          // if it's a function and doesn't have cid attached,\n          // assume it's an async component resolve function.\n          // we are not using Vue's default async resolving mechanism because\n          // we want to halt the navigation until the incoming component has been\n          // resolved.\n          if (typeof def === 'function' && def.cid === undefined) {\n            hasAsync = true;\n            pending++;\n  \n            var resolve = once(function (resolvedDef) {\n              if (isESModule(resolvedDef)) {\n                resolvedDef = resolvedDef.default;\n              }\n              // save resolved on async factory in case it's used elsewhere\n              def.resolved = typeof resolvedDef === 'function'\n                ? resolvedDef\n                : _Vue.extend(resolvedDef);\n              match.components[key] = resolvedDef;\n              pending--;\n              if (pending <= 0) {\n                next();\n              }\n            });\n  \n            var reject = once(function (reason) {\n              var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n              warn(false, msg);\n              if (!error) {\n                error = isError(reason)\n                  ? reason\n                  : new Error(msg);\n                next(error);\n              }\n            });\n  \n            var res;\n            try {\n              res = def(resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n            if (res) {\n              if (typeof res.then === 'function') {\n                res.then(resolve, reject);\n              } else {\n                // new syntax in Vue 2.3\n                var comp = res.component;\n                if (comp && typeof comp.then === 'function') {\n                  comp.then(resolve, reject);\n                }\n              }\n            }\n          }\n        });\n  \n        if (!hasAsync) { next(); }\n      }\n    }\n  \n    function flatMapComponents (\n      matched,\n      fn\n    ) {\n      return flatten(matched.map(function (m) {\n        return Object.keys(m.components).map(function (key) { return fn(\n          m.components[key],\n          m.instances[key],\n          m, key\n        ); })\n      }))\n    }\n  \n    function flatten (arr) {\n      return Array.prototype.concat.apply([], arr)\n    }\n  \n    var hasSymbol =\n      typeof Symbol === 'function' &&\n      typeof Symbol.toStringTag === 'symbol';\n  \n    function isESModule (obj) {\n      return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')\n    }\n  \n    // in Webpack 2, require.ensure now also returns a Promise\n    // so the resolve/reject functions may get called an extra time\n    // if the user uses an arrow function shorthand that happens to\n    // return that Promise.\n    function once (fn) {\n      var called = false;\n      return function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n  \n        if (called) { return }\n        called = true;\n        return fn.apply(this, args)\n      }\n    }\n  \n    /*  */\n  \n    var History = function History (router, base) {\n      this.router = router;\n      this.base = normalizeBase(base);\n      // start with a route object that stands for \"nowhere\"\n      this.current = START;\n      this.pending = null;\n      this.ready = false;\n      this.readyCbs = [];\n      this.readyErrorCbs = [];\n      this.errorCbs = [];\n      this.listeners = [];\n    };\n  \n    History.prototype.listen = function listen (cb) {\n      this.cb = cb;\n    };\n  \n    History.prototype.onReady = function onReady (cb, errorCb) {\n      if (this.ready) {\n        cb();\n      } else {\n        this.readyCbs.push(cb);\n        if (errorCb) {\n          this.readyErrorCbs.push(errorCb);\n        }\n      }\n    };\n  \n    History.prototype.onError = function onError (errorCb) {\n      this.errorCbs.push(errorCb);\n    };\n  \n    History.prototype.transitionTo = function transitionTo (\n      location,\n      onComplete,\n      onAbort\n    ) {\n        var this$1$1 = this;\n  \n      var route;\n      // catch redirect option https://github.com/vuejs/vue-router/issues/3201\n      try {\n        route = this.router.match(location, this.current);\n      } catch (e) {\n        this.errorCbs.forEach(function (cb) {\n          cb(e);\n        });\n        // Exception should still be thrown\n        throw e\n      }\n      var prev = this.current;\n      this.confirmTransition(\n        route,\n        function () {\n          this$1$1.updateRoute(route);\n          onComplete && onComplete(route);\n          this$1$1.ensureURL();\n          this$1$1.router.afterHooks.forEach(function (hook) {\n            hook && hook(route, prev);\n          });\n  \n          // fire ready cbs once\n          if (!this$1$1.ready) {\n            this$1$1.ready = true;\n            this$1$1.readyCbs.forEach(function (cb) {\n              cb(route);\n            });\n          }\n        },\n        function (err) {\n          if (onAbort) {\n            onAbort(err);\n          }\n          if (err && !this$1$1.ready) {\n            // Initial redirection should not mark the history as ready yet\n            // because it's triggered by the redirection instead\n            // https://github.com/vuejs/vue-router/issues/3225\n            // https://github.com/vuejs/vue-router/issues/3331\n            if (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) {\n              this$1$1.ready = true;\n              this$1$1.readyErrorCbs.forEach(function (cb) {\n                cb(err);\n              });\n            }\n          }\n        }\n      );\n    };\n  \n    History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n      var current = this.current;\n      this.pending = route;\n      var abort = function (err) {\n        // changed after adding errors with\n        // https://github.com/vuejs/vue-router/pull/3047 before that change,\n        // redirect and aborted navigation would produce an err == null\n        if (!isNavigationFailure(err) && isError(err)) {\n          if (this$1$1.errorCbs.length) {\n            this$1$1.errorCbs.forEach(function (cb) {\n              cb(err);\n            });\n          } else {\n            {\n              warn(false, 'uncaught error during route navigation:');\n            }\n            console.error(err);\n          }\n        }\n        onAbort && onAbort(err);\n      };\n      var lastRouteIndex = route.matched.length - 1;\n      var lastCurrentIndex = current.matched.length - 1;\n      if (\n        isSameRoute(route, current) &&\n        // in the case the route map has been dynamically appended to\n        lastRouteIndex === lastCurrentIndex &&\n        route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]\n      ) {\n        this.ensureURL();\n        if (route.hash) {\n          handleScroll(this.router, current, route, false);\n        }\n        return abort(createNavigationDuplicatedError(current, route))\n      }\n  \n      var ref = resolveQueue(\n        this.current.matched,\n        route.matched\n      );\n        var updated = ref.updated;\n        var deactivated = ref.deactivated;\n        var activated = ref.activated;\n  \n      var queue = [].concat(\n        // in-component leave guards\n        extractLeaveGuards(deactivated),\n        // global before hooks\n        this.router.beforeHooks,\n        // in-component update hooks\n        extractUpdateHooks(updated),\n        // in-config enter guards\n        activated.map(function (m) { return m.beforeEnter; }),\n        // async components\n        resolveAsyncComponents(activated)\n      );\n  \n      var iterator = function (hook, next) {\n        if (this$1$1.pending !== route) {\n          return abort(createNavigationCancelledError(current, route))\n        }\n        try {\n          hook(route, current, function (to) {\n            if (to === false) {\n              // next(false) -> abort navigation, ensure current URL\n              this$1$1.ensureURL(true);\n              abort(createNavigationAbortedError(current, route));\n            } else if (isError(to)) {\n              this$1$1.ensureURL(true);\n              abort(to);\n            } else if (\n              typeof to === 'string' ||\n              (typeof to === 'object' &&\n                (typeof to.path === 'string' || typeof to.name === 'string'))\n            ) {\n              // next('/') or next({ path: '/' }) -> redirect\n              abort(createNavigationRedirectedError(current, route));\n              if (typeof to === 'object' && to.replace) {\n                this$1$1.replace(to);\n              } else {\n                this$1$1.push(to);\n              }\n            } else {\n              // confirm transition and pass on the value\n              next(to);\n            }\n          });\n        } catch (e) {\n          abort(e);\n        }\n      };\n  \n      runQueue(queue, iterator, function () {\n        // wait until async components are resolved before\n        // extracting in-component enter guards\n        var enterGuards = extractEnterGuards(activated);\n        var queue = enterGuards.concat(this$1$1.router.resolveHooks);\n        runQueue(queue, iterator, function () {\n          if (this$1$1.pending !== route) {\n            return abort(createNavigationCancelledError(current, route))\n          }\n          this$1$1.pending = null;\n          onComplete(route);\n          if (this$1$1.router.app) {\n            this$1$1.router.app.$nextTick(function () {\n              handleRouteEntered(route);\n            });\n          }\n        });\n      });\n    };\n  \n    History.prototype.updateRoute = function updateRoute (route) {\n      this.current = route;\n      this.cb && this.cb(route);\n    };\n  \n    History.prototype.setupListeners = function setupListeners () {\n      // Default implementation is empty\n    };\n  \n    History.prototype.teardown = function teardown () {\n      // clean up event listeners\n      // https://github.com/vuejs/vue-router/issues/2341\n      this.listeners.forEach(function (cleanupListener) {\n        cleanupListener();\n      });\n      this.listeners = [];\n  \n      // reset current history route\n      // https://github.com/vuejs/vue-router/issues/3294\n      this.current = START;\n      this.pending = null;\n    };\n  \n    function normalizeBase (base) {\n      if (!base) {\n        if (inBrowser) {\n          // respect <base> tag\n          var baseEl = document.querySelector('base');\n          base = (baseEl && baseEl.getAttribute('href')) || '/';\n          // strip full URL origin\n          base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n        } else {\n          base = '/';\n        }\n      }\n      // make sure there's the starting slash\n      if (base.charAt(0) !== '/') {\n        base = '/' + base;\n      }\n      // remove trailing slash\n      return base.replace(/\\/$/, '')\n    }\n  \n    function resolveQueue (\n      current,\n      next\n    ) {\n      var i;\n      var max = Math.max(current.length, next.length);\n      for (i = 0; i < max; i++) {\n        if (current[i] !== next[i]) {\n          break\n        }\n      }\n      return {\n        updated: next.slice(0, i),\n        activated: next.slice(i),\n        deactivated: current.slice(i)\n      }\n    }\n  \n    function extractGuards (\n      records,\n      name,\n      bind,\n      reverse\n    ) {\n      var guards = flatMapComponents(records, function (def, instance, match, key) {\n        var guard = extractGuard(def, name);\n        if (guard) {\n          return Array.isArray(guard)\n            ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n            : bind(guard, instance, match, key)\n        }\n      });\n      return flatten(reverse ? guards.reverse() : guards)\n    }\n  \n    function extractGuard (\n      def,\n      key\n    ) {\n      if (typeof def !== 'function') {\n        // extend now so that global mixins are applied.\n        def = _Vue.extend(def);\n      }\n      return def.options[key]\n    }\n  \n    function extractLeaveGuards (deactivated) {\n      return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n    }\n  \n    function extractUpdateHooks (updated) {\n      return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n    }\n  \n    function bindGuard (guard, instance) {\n      if (instance) {\n        return function boundRouteGuard () {\n          return guard.apply(instance, arguments)\n        }\n      }\n    }\n  \n    function extractEnterGuards (\n      activated\n    ) {\n      return extractGuards(\n        activated,\n        'beforeRouteEnter',\n        function (guard, _, match, key) {\n          return bindEnterGuard(guard, match, key)\n        }\n      )\n    }\n  \n    function bindEnterGuard (\n      guard,\n      match,\n      key\n    ) {\n      return function routeEnterGuard (to, from, next) {\n        return guard(to, from, function (cb) {\n          if (typeof cb === 'function') {\n            if (!match.enteredCbs[key]) {\n              match.enteredCbs[key] = [];\n            }\n            match.enteredCbs[key].push(cb);\n          }\n          next(cb);\n        })\n      }\n    }\n  \n    /*  */\n  \n    var HTML5History = /*@__PURE__*/(function (History) {\n      function HTML5History (router, base) {\n        History.call(this, router, base);\n  \n        this._startLocation = getLocation(this.base);\n      }\n  \n      if ( History ) HTML5History.__proto__ = History;\n      HTML5History.prototype = Object.create( History && History.prototype );\n      HTML5History.prototype.constructor = HTML5History;\n  \n      HTML5History.prototype.setupListeners = function setupListeners () {\n        var this$1$1 = this;\n  \n        if (this.listeners.length > 0) {\n          return\n        }\n  \n        var router = this.router;\n        var expectScroll = router.options.scrollBehavior;\n        var supportsScroll = supportsPushState && expectScroll;\n  \n        if (supportsScroll) {\n          this.listeners.push(setupScroll());\n        }\n  \n        var handleRoutingEvent = function () {\n          var current = this$1$1.current;\n  \n          // Avoiding first `popstate` event dispatched in some browsers but first\n          // history route not updated since async guard at the same time.\n          var location = getLocation(this$1$1.base);\n          if (this$1$1.current === START && location === this$1$1._startLocation) {\n            return\n          }\n  \n          this$1$1.transitionTo(location, function (route) {\n            if (supportsScroll) {\n              handleScroll(router, route, current, true);\n            }\n          });\n        };\n        window.addEventListener('popstate', handleRoutingEvent);\n        this.listeners.push(function () {\n          window.removeEventListener('popstate', handleRoutingEvent);\n        });\n      };\n  \n      HTML5History.prototype.go = function go (n) {\n        window.history.go(n);\n      };\n  \n      HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n        var ref = this;\n        var fromRoute = ref.current;\n        this.transitionTo(location, function (route) {\n          pushState(cleanPath(this$1$1.base + route.fullPath));\n          handleScroll(this$1$1.router, route, fromRoute, false);\n          onComplete && onComplete(route);\n        }, onAbort);\n      };\n  \n      HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n        var ref = this;\n        var fromRoute = ref.current;\n        this.transitionTo(location, function (route) {\n          replaceState(cleanPath(this$1$1.base + route.fullPath));\n          handleScroll(this$1$1.router, route, fromRoute, false);\n          onComplete && onComplete(route);\n        }, onAbort);\n      };\n  \n      HTML5History.prototype.ensureURL = function ensureURL (push) {\n        if (getLocation(this.base) !== this.current.fullPath) {\n          var current = cleanPath(this.base + this.current.fullPath);\n          push ? pushState(current) : replaceState(current);\n        }\n      };\n  \n      HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n        return getLocation(this.base)\n      };\n  \n      return HTML5History;\n    }(History));\n  \n    function getLocation (base) {\n      var path = window.location.pathname;\n      var pathLowerCase = path.toLowerCase();\n      var baseLowerCase = base.toLowerCase();\n      // base=\"/a\" shouldn't turn path=\"/app\" into \"/a/pp\"\n      // https://github.com/vuejs/vue-router/issues/3555\n      // so we ensure the trailing slash in the base\n      if (base && ((pathLowerCase === baseLowerCase) ||\n        (pathLowerCase.indexOf(cleanPath(baseLowerCase + '/')) === 0))) {\n        path = path.slice(base.length);\n      }\n      return (path || '/') + window.location.search + window.location.hash\n    }\n  \n    /*  */\n  \n    var HashHistory = /*@__PURE__*/(function (History) {\n      function HashHistory (router, base, fallback) {\n        History.call(this, router, base);\n        // check history fallback deeplinking\n        if (fallback && checkFallback(this.base)) {\n          return\n        }\n        ensureSlash();\n      }\n  \n      if ( History ) HashHistory.__proto__ = History;\n      HashHistory.prototype = Object.create( History && History.prototype );\n      HashHistory.prototype.constructor = HashHistory;\n  \n      // this is delayed until the app mounts\n      // to avoid the hashchange listener being fired too early\n      HashHistory.prototype.setupListeners = function setupListeners () {\n        var this$1$1 = this;\n  \n        if (this.listeners.length > 0) {\n          return\n        }\n  \n        var router = this.router;\n        var expectScroll = router.options.scrollBehavior;\n        var supportsScroll = supportsPushState && expectScroll;\n  \n        if (supportsScroll) {\n          this.listeners.push(setupScroll());\n        }\n  \n        var handleRoutingEvent = function () {\n          var current = this$1$1.current;\n          if (!ensureSlash()) {\n            return\n          }\n          this$1$1.transitionTo(getHash(), function (route) {\n            if (supportsScroll) {\n              handleScroll(this$1$1.router, route, current, true);\n            }\n            if (!supportsPushState) {\n              replaceHash(route.fullPath);\n            }\n          });\n        };\n        var eventType = supportsPushState ? 'popstate' : 'hashchange';\n        window.addEventListener(\n          eventType,\n          handleRoutingEvent\n        );\n        this.listeners.push(function () {\n          window.removeEventListener(eventType, handleRoutingEvent);\n        });\n      };\n  \n      HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n        var ref = this;\n        var fromRoute = ref.current;\n        this.transitionTo(\n          location,\n          function (route) {\n            pushHash(route.fullPath);\n            handleScroll(this$1$1.router, route, fromRoute, false);\n            onComplete && onComplete(route);\n          },\n          onAbort\n        );\n      };\n  \n      HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n        var ref = this;\n        var fromRoute = ref.current;\n        this.transitionTo(\n          location,\n          function (route) {\n            replaceHash(route.fullPath);\n            handleScroll(this$1$1.router, route, fromRoute, false);\n            onComplete && onComplete(route);\n          },\n          onAbort\n        );\n      };\n  \n      HashHistory.prototype.go = function go (n) {\n        window.history.go(n);\n      };\n  \n      HashHistory.prototype.ensureURL = function ensureURL (push) {\n        var current = this.current.fullPath;\n        if (getHash() !== current) {\n          push ? pushHash(current) : replaceHash(current);\n        }\n      };\n  \n      HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n        return getHash()\n      };\n  \n      return HashHistory;\n    }(History));\n  \n    function checkFallback (base) {\n      var location = getLocation(base);\n      if (!/^\\/#/.test(location)) {\n        window.location.replace(cleanPath(base + '/#' + location));\n        return true\n      }\n    }\n  \n    function ensureSlash () {\n      var path = getHash();\n      if (path.charAt(0) === '/') {\n        return true\n      }\n      replaceHash('/' + path);\n      return false\n    }\n  \n    function getHash () {\n      // We can't use window.location.hash here because it's not\n      // consistent across browsers - Firefox will pre-decode it!\n      var href = window.location.href;\n      var index = href.indexOf('#');\n      // empty path\n      if (index < 0) { return '' }\n  \n      href = href.slice(index + 1);\n  \n      return href\n    }\n  \n    function getUrl (path) {\n      var href = window.location.href;\n      var i = href.indexOf('#');\n      var base = i >= 0 ? href.slice(0, i) : href;\n      return (base + \"#\" + path)\n    }\n  \n    function pushHash (path) {\n      if (supportsPushState) {\n        pushState(getUrl(path));\n      } else {\n        window.location.hash = path;\n      }\n    }\n  \n    function replaceHash (path) {\n      if (supportsPushState) {\n        replaceState(getUrl(path));\n      } else {\n        window.location.replace(getUrl(path));\n      }\n    }\n  \n    /*  */\n  \n    var AbstractHistory = /*@__PURE__*/(function (History) {\n      function AbstractHistory (router, base) {\n        History.call(this, router, base);\n        this.stack = [];\n        this.index = -1;\n      }\n  \n      if ( History ) AbstractHistory.__proto__ = History;\n      AbstractHistory.prototype = Object.create( History && History.prototype );\n      AbstractHistory.prototype.constructor = AbstractHistory;\n  \n      AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n        this.transitionTo(\n          location,\n          function (route) {\n            this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index + 1).concat(route);\n            this$1$1.index++;\n            onComplete && onComplete(route);\n          },\n          onAbort\n        );\n      };\n  \n      AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n        this.transitionTo(\n          location,\n          function (route) {\n            this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index).concat(route);\n            onComplete && onComplete(route);\n          },\n          onAbort\n        );\n      };\n  \n      AbstractHistory.prototype.go = function go (n) {\n        var this$1$1 = this;\n  \n        var targetIndex = this.index + n;\n        if (targetIndex < 0 || targetIndex >= this.stack.length) {\n          return\n        }\n        var route = this.stack[targetIndex];\n        this.confirmTransition(\n          route,\n          function () {\n            var prev = this$1$1.current;\n            this$1$1.index = targetIndex;\n            this$1$1.updateRoute(route);\n            this$1$1.router.afterHooks.forEach(function (hook) {\n              hook && hook(route, prev);\n            });\n          },\n          function (err) {\n            if (isNavigationFailure(err, NavigationFailureType.duplicated)) {\n              this$1$1.index = targetIndex;\n            }\n          }\n        );\n      };\n  \n      AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n        var current = this.stack[this.stack.length - 1];\n        return current ? current.fullPath : '/'\n      };\n  \n      AbstractHistory.prototype.ensureURL = function ensureURL () {\n        // noop\n      };\n  \n      return AbstractHistory;\n    }(History));\n  \n    /*  */\n  \n  \n  \n    var VueRouter = function VueRouter (options) {\n      if ( options === void 0 ) options = {};\n  \n      {\n        warn(this instanceof VueRouter, \"Router must be called with the new operator.\");\n      }\n      this.app = null;\n      this.apps = [];\n      this.options = options;\n      this.beforeHooks = [];\n      this.resolveHooks = [];\n      this.afterHooks = [];\n      this.matcher = createMatcher(options.routes || [], this);\n  \n      var mode = options.mode || 'hash';\n      this.fallback =\n        mode === 'history' && !supportsPushState && options.fallback !== false;\n      if (this.fallback) {\n        mode = 'hash';\n      }\n      if (!inBrowser) {\n        mode = 'abstract';\n      }\n      this.mode = mode;\n  \n      switch (mode) {\n        case 'history':\n          this.history = new HTML5History(this, options.base);\n          break\n        case 'hash':\n          this.history = new HashHistory(this, options.base, this.fallback);\n          break\n        case 'abstract':\n          this.history = new AbstractHistory(this, options.base);\n          break\n        default:\n          {\n            assert(false, (\"invalid mode: \" + mode));\n          }\n      }\n    };\n  \n    var prototypeAccessors = { currentRoute: { configurable: true } };\n  \n    VueRouter.prototype.match = function match (raw, current, redirectedFrom) {\n      return this.matcher.match(raw, current, redirectedFrom)\n    };\n  \n    prototypeAccessors.currentRoute.get = function () {\n      return this.history && this.history.current\n    };\n  \n    VueRouter.prototype.init = function init (app /* Vue component instance */) {\n        var this$1$1 = this;\n  \n      assert(\n          install.installed,\n          \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n            \"before creating root instance.\"\n        );\n  \n      this.apps.push(app);\n  \n      // set up app destroyed handler\n      // https://github.com/vuejs/vue-router/issues/2639\n      app.$once('hook:destroyed', function () {\n        // clean out app from this.apps array once destroyed\n        var index = this$1$1.apps.indexOf(app);\n        if (index > -1) { this$1$1.apps.splice(index, 1); }\n        // ensure we still have a main app or null if no apps\n        // we do not release the router so it can be reused\n        if (this$1$1.app === app) { this$1$1.app = this$1$1.apps[0] || null; }\n  \n        if (!this$1$1.app) { this$1$1.history.teardown(); }\n      });\n  \n      // main app previously initialized\n      // return as we don't need to set up new history listener\n      if (this.app) {\n        return\n      }\n  \n      this.app = app;\n  \n      var history = this.history;\n  \n      if (history instanceof HTML5History || history instanceof HashHistory) {\n        var handleInitialScroll = function (routeOrError) {\n          var from = history.current;\n          var expectScroll = this$1$1.options.scrollBehavior;\n          var supportsScroll = supportsPushState && expectScroll;\n  \n          if (supportsScroll && 'fullPath' in routeOrError) {\n            handleScroll(this$1$1, routeOrError, from, false);\n          }\n        };\n        var setupListeners = function (routeOrError) {\n          history.setupListeners();\n          handleInitialScroll(routeOrError);\n        };\n        history.transitionTo(\n          history.getCurrentLocation(),\n          setupListeners,\n          setupListeners\n        );\n      }\n  \n      history.listen(function (route) {\n        this$1$1.apps.forEach(function (app) {\n          app._route = route;\n        });\n      });\n    };\n  \n    VueRouter.prototype.beforeEach = function beforeEach (fn) {\n      return registerHook(this.beforeHooks, fn)\n    };\n  \n    VueRouter.prototype.beforeResolve = function beforeResolve (fn) {\n      return registerHook(this.resolveHooks, fn)\n    };\n  \n    VueRouter.prototype.afterEach = function afterEach (fn) {\n      return registerHook(this.afterHooks, fn)\n    };\n  \n    VueRouter.prototype.onReady = function onReady (cb, errorCb) {\n      this.history.onReady(cb, errorCb);\n    };\n  \n    VueRouter.prototype.onError = function onError (errorCb) {\n      this.history.onError(errorCb);\n    };\n  \n    VueRouter.prototype.push = function push (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n      // $flow-disable-line\n      if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n        return new Promise(function (resolve, reject) {\n          this$1$1.history.push(location, resolve, reject);\n        })\n      } else {\n        this.history.push(location, onComplete, onAbort);\n      }\n    };\n  \n    VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n        var this$1$1 = this;\n  \n      // $flow-disable-line\n      if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n        return new Promise(function (resolve, reject) {\n          this$1$1.history.replace(location, resolve, reject);\n        })\n      } else {\n        this.history.replace(location, onComplete, onAbort);\n      }\n    };\n  \n    VueRouter.prototype.go = function go (n) {\n      this.history.go(n);\n    };\n  \n    VueRouter.prototype.back = function back () {\n      this.go(-1);\n    };\n  \n    VueRouter.prototype.forward = function forward () {\n      this.go(1);\n    };\n  \n    VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n      var route = to\n        ? to.matched\n          ? to\n          : this.resolve(to).route\n        : this.currentRoute;\n      if (!route) {\n        return []\n      }\n      return [].concat.apply(\n        [],\n        route.matched.map(function (m) {\n          return Object.keys(m.components).map(function (key) {\n            return m.components[key]\n          })\n        })\n      )\n    };\n  \n    VueRouter.prototype.resolve = function resolve (\n      to,\n      current,\n      append\n    ) {\n      current = current || this.history.current;\n      var location = normalizeLocation(to, current, append, this);\n      var route = this.match(location, current);\n      var fullPath = route.redirectedFrom || route.fullPath;\n      var base = this.history.base;\n      var href = createHref(base, fullPath, this.mode);\n      return {\n        location: location,\n        route: route,\n        href: href,\n        // for backwards compat\n        normalizedTo: location,\n        resolved: route\n      }\n    };\n  \n    VueRouter.prototype.getRoutes = function getRoutes () {\n      return this.matcher.getRoutes()\n    };\n  \n    VueRouter.prototype.addRoute = function addRoute (parentOrRoute, route) {\n      this.matcher.addRoute(parentOrRoute, route);\n      if (this.history.current !== START) {\n        this.history.transitionTo(this.history.getCurrentLocation());\n      }\n    };\n  \n    VueRouter.prototype.addRoutes = function addRoutes (routes) {\n      {\n        warn(false, 'router.addRoutes() is deprecated and has been removed in Vue Router 4. Use router.addRoute() instead.');\n      }\n      this.matcher.addRoutes(routes);\n      if (this.history.current !== START) {\n        this.history.transitionTo(this.history.getCurrentLocation());\n      }\n    };\n  \n    Object.defineProperties( VueRouter.prototype, prototypeAccessors );\n  \n    var VueRouter$1 = VueRouter;\n  \n    function registerHook (list, fn) {\n      list.push(fn);\n      return function () {\n        var i = list.indexOf(fn);\n        if (i > -1) { list.splice(i, 1); }\n      }\n    }\n  \n    function createHref (base, fullPath, mode) {\n      var path = mode === 'hash' ? '#' + fullPath : fullPath;\n      return base ? cleanPath(base + '/' + path) : path\n    }\n  \n    // We cannot remove this as it would be a breaking change\n    VueRouter.install = install;\n    VueRouter.version = '3.6.5';\n    VueRouter.isNavigationFailure = isNavigationFailure;\n    VueRouter.NavigationFailureType = NavigationFailureType;\n    VueRouter.START_LOCATION = START;\n  \n    if (inBrowser && window.Vue) {\n      window.Vue.use(VueRouter);\n    }\n  \n    return VueRouter$1;\n  \n  }));"],"names":["global","factory","this","assert","condition","message","Error","warn","console","extend","a","b","key","encodeReserveRE","encodeReserveReplacer","c","charCodeAt","toString","commaRE","encode","str","encodeURIComponent","replace","decode","decodeURIComponent","err","castQueryParamValue","value","String","parseQuery","query","res","trim","split","forEach","param","parts","shift","val","length","join","undefined","Array","isArray","push","stringifyQuery","obj","Object","keys","map","result","val2","filter","x","trailingSlashRE","createRoute","record","location","redirectedFrom","router","options","clone","e","route","name","meta","path","hash","params","fullPath","getFullPath","matched","formatMatch","freeze","START","unshift","parent","ref","_stringifyQuery","isSameRoute","onlyPath","isObjectEqual","aKeys","sort","bKeys","every","i","aVal","bVal","handleRouteEntered","instances","instance","cbs","enteredCbs","i$1","_isBeingDestroyed","View","functional","props","type","default","render","_","children","data","routerView","h","$createElement","$route","cache","_routerViewCache","depth","inactive","_routerRoot","vnodeData","$vnode","keepAlive","_directInactive","_inactive","$parent","routerViewDepth","cachedData","cachedComponent","component","configProps","fillPropsinData","components","registerRouteInstance","vm","current","hook","prepatch","vnode","componentInstance","init","propsToPass","config","resolveProps","attrs","resolvePath","relative","base","append","firstChar","charAt","stack","pop","segments","segment","cleanPath","isarray","arr","prototype","call","pathToRegexp_1","pathToRegexp","parse_1","parse","compile_1","tokensToFunction","tokensToFunction_1","tokensToRegExp_1","tokensToRegExp","PATH_REGEXP","RegExp","tokens","index","defaultDelimiter","delimiter","exec","m","escaped","offset","slice","next","prefix","capture","group","modifier","asterisk","partial","repeat","optional","pattern","escapeGroup","escapeString","substr","encodeURIComponentPretty","encodeURI","toUpperCase","matches","flags","opts","pretty","token","TypeError","JSON","stringify","j","test","attachKeys","re","sensitive","strict","end","endsWithDelimiter","groups","source","match","regexpToRegexp","arrayToRegexp","stringToRegexp","compile","regexpCompileCache","create","fillParams","routeMsg","filler","pathMatch","normalizeLocation","raw","_normalized","params$1","rawPath","parsedPath","hashIndex","indexOf","queryIndex","parsePath","basePath","extraQuery","_parseQuery","parsedQuery","resolveQuery","warnedCustomSlot","warnedTagProp","warnedEventProp","_Vue","noop","Link","to","required","tag","custom","Boolean","exact","exactPath","activeClass","exactActiveClass","ariaCurrentValue","event","this$1$1","$router","resolve","href","classes","globalActiveClass","linkActiveClass","globalExactActiveClass","linkExactActiveClass","activeClassFallback","exactActiveClassFallback","compareTarget","target","queryIncludes","isIncludedRoute","handler","guardEvent","on","click","class","scopedSlot","$scopedSlots","$hasNormal","navigate","isActive","isExactActive","$options","propsData","findAnchor","$slots","isStatic","aData","handler$1","event$1","aAttrs","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","getAttribute","preventDefault","child","install","Vue","installed","isDef","v","registerInstance","callVal","_parentVnode","mixin","beforeCreate","_router","util","defineReactive","history","destroyed","defineProperty","get","_route","strats","optionMergeStrategies","beforeRouteEnter","beforeRouteLeave","beforeRouteUpdate","created","inBrowser","window","createRouteMap","routes","oldPathList","oldPathMap","oldNameMap","parentRoute","pathList","pathMap","nameMap","addRouteRecord","l","splice","found","matchAs","pathToRegexpOptions","normalizedPath","normalizePath","caseSensitive","regex","compileRouteRegex","alias","redirect","beforeEnter","some","childMatchAs","aliases","aliasRoute","createMatcher","currentRoute","_createRoute","paramNames","record$1","matchRoute","originalRedirect","hasOwnProperty","resolveRecordPath","aliasedMatch","aliasedRecord","addRoute","parentOrRoute","getRoutes","addRoutes","len","Time","performance","now","Date","genStateKey","toFixed","_key","getStateKey","setStateKey","positionStore","setupScroll","scrollRestoration","protocolAndPath","protocol","host","absolutePath","stateCopy","state","replaceState","addEventListener","handlePopState","removeEventListener","handleScroll","from","isPop","app","behavior","scrollBehavior","$nextTick","position","getScrollPosition","shouldScroll","then","scrollToPosition","catch","saveScrollPosition","pageXOffset","y","pageYOffset","isValidPosition","isNumber","normalizePosition","hashStartsWithNumberRE","isObject","selector","el","document","getElementById","querySelector","docRect","documentElement","getBoundingClientRect","elRect","left","top","getElementPosition","style","scrollTo","ua","supportsPushState","navigator","userAgent","pushState","url","NavigationFailureType","redirected","aborted","cancelled","duplicated","createNavigationRedirectedError","createRouterError","propertiesToLog","stringifyRoute","createNavigationCancelledError","error","_isRouter","isError","isNavigationFailure","errorType","runQueue","queue","fn","cb","step","resolveAsyncComponents","hasAsync","pending","flatMapComponents","def","cid","once","resolvedDef","__esModule","hasSymbol","Symbol","toStringTag","resolved","reject","reason","msg","comp","flatten","concat","apply","called","args","arguments","History","baseEl","normalizeBase","ready","readyCbs","readyErrorCbs","errorCbs","listeners","extractGuards","records","bind","reverse","guards","guard","extractGuard","bindGuard","listen","onReady","errorCb","onError","transitionTo","onComplete","onAbort","prev","confirmTransition","updateRoute","ensureURL","afterHooks","abort","lastRouteIndex","lastCurrentIndex","max","Math","updated","activated","deactivated","resolveQueue","extractLeaveGuards","beforeHooks","extractUpdateHooks","iterator","createNavigationAbortedError","enterGuards","bindEnterGuard","extractEnterGuards","resolveHooks","setupListeners","teardown","cleanupListener","HTML5History","_startLocation","getLocation","__proto__","constructor","expectScroll","supportsScroll","handleRoutingEvent","go","n","fromRoute","getCurrentLocation","pathname","pathLowerCase","toLowerCase","baseLowerCase","search","HashHistory","fallback","checkFallback","ensureSlash","getHash","replaceHash","eventType","pushHash","getUrl","AbstractHistory","targetIndex","VueRouter","apps","matcher","mode","prototypeAccessors","configurable","$once","routeOrError","handleInitialScroll","beforeEach","registerHook","beforeResolve","afterEach","Promise","back","forward","getMatchedComponents","createHref","normalizedTo","defineProperties","VueRouter$1","list","version","START_LOCATION","use","exports","module","define","amd","globalThis","self"],"mappings":"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"}