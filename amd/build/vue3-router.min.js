define("tool_vue/vue3-router",["exports","tool_vue/vue3"],(function(_exports,_vue){var obj;
/*!
    * vue-router v4.2.5
    * (c) 2023 Eduardo San Martin Morote
    * @license MIT
    */Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.default=void 0;var VueRouter=function(exports,vue){const isBrowser="undefined"!=typeof window;function isESModule(obj){return obj.__esModule||"Module"===obj[Symbol.toStringTag]}const assign=Object.assign;function applyToParams(fn,params){const newParams={};for(const key in params){const value=params[key];newParams[key]=isArray(value)?value.map(fn):fn(value)}return newParams}const noop=()=>{},isArray=Array.isArray;function warn(msg){const args=Array.from(arguments).slice(1);console.warn.apply(console,["[Vue Router warn]: "+msg].concat(args))}const TRAILING_SLASH_RE=/\/$/;function parseURL(parseQuery,location){let path,currentLocation=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"/",query={},searchString="",hash="";const hashPos=location.indexOf("#");let searchPos=location.indexOf("?");return hashPos<searchPos&&hashPos>=0&&(searchPos=-1),searchPos>-1&&(path=location.slice(0,searchPos),searchString=location.slice(searchPos+1,hashPos>-1?hashPos:location.length),query=parseQuery(searchString)),hashPos>-1&&(path=path||location.slice(0,hashPos),hash=location.slice(hashPos,location.length)),path=resolveRelativePath(null!=path?path:location,currentLocation),{fullPath:path+(searchString&&"?")+searchString+hash,path:path,query:query,hash:hash}}function stripBase(pathname,base){return base&&pathname.toLowerCase().startsWith(base.toLowerCase())?pathname.slice(base.length)||"/":pathname}function isSameRouteLocation(stringifyQuery,a,b){const aLastIndex=a.matched.length-1,bLastIndex=b.matched.length-1;return aLastIndex>-1&&aLastIndex===bLastIndex&&isSameRouteRecord(a.matched[aLastIndex],b.matched[bLastIndex])&&isSameRouteLocationParams(a.params,b.params)&&stringifyQuery(a.query)===stringifyQuery(b.query)&&a.hash===b.hash}function isSameRouteRecord(a,b){return(a.aliasOf||a)===(b.aliasOf||b)}function isSameRouteLocationParams(a,b){if(Object.keys(a).length!==Object.keys(b).length)return!1;for(const key in a)if(!isSameRouteLocationParamsValue(a[key],b[key]))return!1;return!0}function isSameRouteLocationParamsValue(a,b){return isArray(a)?isEquivalentArray(a,b):isArray(b)?isEquivalentArray(b,a):a===b}function isEquivalentArray(a,b){return isArray(b)?a.length===b.length&&a.every(((value,i)=>value===b[i])):1===a.length&&a[0]===b}function resolveRelativePath(to,from){if(to.startsWith("/"))return to;if(!from.startsWith("/"))return warn('Cannot resolve a relative location without an absolute path. Trying to resolve "'.concat(to,'" from "').concat(from,'". It should look like "/').concat(from,'".')),to;if(!to)return from;const fromSegments=from.split("/"),toSegments=to.split("/"),lastToSegment=toSegments[toSegments.length-1];".."!==lastToSegment&&"."!==lastToSegment||toSegments.push("");let toPosition,segment,position=fromSegments.length-1;for(toPosition=0;toPosition<toSegments.length;toPosition++)if(segment=toSegments[toPosition],"."!==segment){if(".."!==segment)break;position>1&&position--}return fromSegments.slice(0,position).join("/")+"/"+toSegments.slice(toPosition-(toPosition===toSegments.length?1:0)).join("/")}var NavigationType,NavigationDirection;!function(NavigationType){NavigationType.pop="pop",NavigationType.push="push"}(NavigationType||(NavigationType={})),function(NavigationDirection){NavigationDirection.back="back",NavigationDirection.forward="forward",NavigationDirection.unknown=""}(NavigationDirection||(NavigationDirection={}));function normalizeBase(base){if(!base)if(isBrowser){const baseEl=document.querySelector("base");base=(base=baseEl&&baseEl.getAttribute("href")||"/").replace(/^\w+:\/\/[^\/]+/,"")}else base="/";return"/"!==base[0]&&"#"!==base[0]&&(base="/"+base),base.replace(TRAILING_SLASH_RE,"")}const BEFORE_HASH_RE=/^[^#]+#/;function createHref(base,location){return base.replace(BEFORE_HASH_RE,"#")+location}const computeScrollPosition=()=>({left:window.pageXOffset,top:window.pageYOffset});function scrollToPosition(position){let scrollToOptions;if("el"in position){const positionEl=position.el,isIdSelector="string"==typeof positionEl&&positionEl.startsWith("#");if(!("string"!=typeof position.el||isIdSelector&&document.getElementById(position.el.slice(1))))try{const foundEl=document.querySelector(position.el);if(isIdSelector&&foundEl)return void warn('The selector "'.concat(position.el,'" should be passed as "el: document.querySelector(\'').concat(position.el,'\')" because it starts with "#".'))}catch(err){return void warn('The selector "'.concat(position.el,'" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).'))}const el="string"==typeof positionEl?isIdSelector?document.getElementById(positionEl.slice(1)):document.querySelector(positionEl):positionEl;if(!el)return void warn("Couldn't find element using selector \"".concat(position.el,'" returned by scrollBehavior.'));scrollToOptions=function(el,offset){const docRect=document.documentElement.getBoundingClientRect(),elRect=el.getBoundingClientRect();return{behavior:offset.behavior,left:elRect.left-docRect.left-(offset.left||0),top:elRect.top-docRect.top-(offset.top||0)}}(el,position)}else scrollToOptions=position;"scrollBehavior"in document.documentElement.style?window.scrollTo(scrollToOptions):window.scrollTo(null!=scrollToOptions.left?scrollToOptions.left:window.pageXOffset,null!=scrollToOptions.top?scrollToOptions.top:window.pageYOffset)}function getScrollKey(path,delta){return(history.state?history.state.position-delta:-1)+path}const scrollPositions=new Map;let createBaseLocation=()=>location.protocol+"//"+location.host;function createCurrentLocation(base,location){const{pathname:pathname,search:search,hash:hash}=location,hashPos=base.indexOf("#");if(hashPos>-1){let slicePos=hash.includes(base.slice(hashPos))?base.slice(hashPos).length:1,pathFromHash=hash.slice(slicePos);return"/"!==pathFromHash[0]&&(pathFromHash="/"+pathFromHash),stripBase(pathFromHash,"")}return stripBase(pathname,base)+search+hash}function buildState(back,current,forward){let replaced=arguments.length>3&&void 0!==arguments[3]&&arguments[3],computeScroll=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return{back:back,current:current,forward:forward,replaced:replaced,position:window.history.length,scroll:computeScroll?computeScrollPosition():null}}function createWebHistory(base){const historyNavigation=function(base){const{history:history,location:location}=window,currentLocation={value:createCurrentLocation(base,location)},historyState={value:history.state};function changeLocation(to,state,replace){const hashIndex=base.indexOf("#"),url=hashIndex>-1?(location.host&&document.querySelector("base")?base:base.slice(hashIndex))+to:createBaseLocation()+base+to;try{history[replace?"replaceState":"pushState"](state,"",url),historyState.value=state}catch(err){warn("Error with push/replace State",err),location[replace?"replace":"assign"](url)}}return historyState.value||changeLocation(currentLocation.value,{back:null,current:currentLocation.value,forward:null,position:history.length-1,replaced:!0,scroll:null},!0),{location:currentLocation,state:historyState,push:function(to,data){const currentState=assign({},historyState.value,history.state,{forward:to,scroll:computeScrollPosition()});history.state||warn("history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\nhistory.replaceState(history.state, '', url)\n\nYou can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state."),changeLocation(currentState.current,currentState,!0),changeLocation(to,assign({},buildState(currentLocation.value,to,null),{position:currentState.position+1},data),!1),currentLocation.value=to},replace:function(to,data){changeLocation(to,assign({},history.state,buildState(historyState.value.back,to,historyState.value.forward,!0),data,{position:historyState.value.position}),!0),currentLocation.value=to}}}(base=normalizeBase(base)),historyListeners=function(base,historyState,currentLocation,replace){let listeners=[],teardowns=[],pauseState=null;const popStateHandler=_ref=>{let{state:state}=_ref;const to=createCurrentLocation(base,location),from=currentLocation.value,fromState=historyState.value;let delta=0;if(state){if(currentLocation.value=to,historyState.value=state,pauseState&&pauseState===from)return void(pauseState=null);delta=fromState?state.position-fromState.position:0}else replace(to);listeners.forEach((listener=>{listener(currentLocation.value,from,{delta:delta,type:NavigationType.pop,direction:delta?delta>0?NavigationDirection.forward:NavigationDirection.back:NavigationDirection.unknown})}))};function beforeUnloadListener(){const{history:history}=window;history.state&&history.replaceState(assign({},history.state,{scroll:computeScrollPosition()}),"")}return window.addEventListener("popstate",popStateHandler),window.addEventListener("beforeunload",beforeUnloadListener,{passive:!0}),{pauseListeners:function(){pauseState=currentLocation.value},listen:function(callback){listeners.push(callback);const teardown=()=>{const index=listeners.indexOf(callback);index>-1&&listeners.splice(index,1)};return teardowns.push(teardown),teardown},destroy:function(){for(const teardown of teardowns)teardown();teardowns=[],window.removeEventListener("popstate",popStateHandler),window.removeEventListener("beforeunload",beforeUnloadListener)}}}(base,historyNavigation.state,historyNavigation.location,historyNavigation.replace);const routerHistory=assign({location:"",base:base,go:function(delta){let triggerListeners=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];triggerListeners||historyListeners.pauseListeners(),history.go(delta)},createHref:createHref.bind(null,base)},historyNavigation,historyListeners);return Object.defineProperty(routerHistory,"location",{enumerable:!0,get:()=>historyNavigation.location.value}),Object.defineProperty(routerHistory,"state",{enumerable:!0,get:()=>historyNavigation.state.value}),routerHistory}function isRouteName(name){return"string"==typeof name||"symbol"==typeof name}const START_LOCATION_NORMALIZED={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},NavigationFailureSymbol=Symbol("navigation failure");var NavigationFailureType;exports.NavigationFailureType=void 0,(NavigationFailureType=exports.NavigationFailureType||(exports.NavigationFailureType={}))[NavigationFailureType.aborted=4]="aborted",NavigationFailureType[NavigationFailureType.cancelled=8]="cancelled",NavigationFailureType[NavigationFailureType.duplicated=16]="duplicated";const ErrorTypeMessages={1(_ref3){let{location:location,currentLocation:currentLocation}=_ref3;return"No match for\n ".concat(JSON.stringify(location)).concat(currentLocation?"\nwhile being at\n"+JSON.stringify(currentLocation):"")},2(_ref4){let{from:from,to:to}=_ref4;return'Redirected from "'.concat(from.fullPath,'" to "').concat(function(to){if("string"==typeof to)return to;if("path"in to)return to.path;const location={};for(const key of propertiesToLog)key in to&&(location[key]=to[key]);return JSON.stringify(location,null,2)}(to),'" via a navigation guard.')},4(_ref5){let{from:from,to:to}=_ref5;return'Navigation aborted from "'.concat(from.fullPath,'" to "').concat(to.fullPath,'" via a navigation guard.')},8(_ref6){let{from:from,to:to}=_ref6;return'Navigation cancelled from "'.concat(from.fullPath,'" to "').concat(to.fullPath,'" with a new navigation.')},16(_ref7){let{from:from,to:to}=_ref7;return'Avoided redundant navigation to current location: "'.concat(from.fullPath,'".')}};function createRouterError(type,params){return assign(new Error(ErrorTypeMessages[type](params)),{type:type,[NavigationFailureSymbol]:!0},params)}function isNavigationFailure(error,type){return error instanceof Error&&NavigationFailureSymbol in error&&(null==type||!!(error.type&type))}const propertiesToLog=["params","query","hash"];const BASE_PATH_PARSER_OPTIONS={sensitive:!1,strict:!1,start:!0,end:!0},REGEX_CHARS_RE=/[.+*?^${}()[\]/\\]/g;function compareScoreArray(a,b){let i=0;for(;i<a.length&&i<b.length;){const diff=b[i]-a[i];if(diff)return diff;i++}return a.length<b.length?1===a.length&&80===a[0]?-1:1:a.length>b.length?1===b.length&&80===b[0]?1:-1:0}function comparePathParserScore(a,b){let i=0;const aScore=a.score,bScore=b.score;for(;i<aScore.length&&i<bScore.length;){const comp=compareScoreArray(aScore[i],bScore[i]);if(comp)return comp;i++}if(1===Math.abs(bScore.length-aScore.length)){if(isLastScoreNegative(aScore))return 1;if(isLastScoreNegative(bScore))return-1}return bScore.length-aScore.length}function isLastScoreNegative(score){const last=score[score.length-1];return score.length>0&&last[last.length-1]<0}const ROOT_TOKEN={type:0,value:""},VALID_PARAM_RE=/[a-zA-Z0-9_]/;function createRouteRecordMatcher(record,parent,options){const parser=function(segments,extraOptions){const options=assign({},BASE_PATH_PARSER_OPTIONS,extraOptions),score=[];let pattern=options.start?"^":"";const keys=[];for(const segment of segments){const segmentScores=segment.length?[]:[90];options.strict&&!segment.length&&(pattern+="/");for(let tokenIndex=0;tokenIndex<segment.length;tokenIndex++){const token=segment[tokenIndex];let subSegmentScore=40+(options.sensitive?.25:0);if(0===token.type)tokenIndex||(pattern+="/"),pattern+=token.value.replace(REGEX_CHARS_RE,"\\$&"),subSegmentScore+=40;else if(1===token.type){const{value:value,repeatable:repeatable,optional:optional,regexp:regexp}=token;keys.push({name:value,repeatable:repeatable,optional:optional});const re=regexp||"[^/]+?";if("[^/]+?"!==re){subSegmentScore+=10;try{new RegExp("(".concat(re,")"))}catch(err){throw new Error('Invalid custom RegExp for param "'.concat(value,'" (').concat(re,"): ")+err.message)}}let subPattern=repeatable?"((?:".concat(re,")(?:/(?:").concat(re,"))*)"):"(".concat(re,")");tokenIndex||(subPattern=optional&&segment.length<2?"(?:/".concat(subPattern,")"):"/"+subPattern),optional&&(subPattern+="?"),pattern+=subPattern,subSegmentScore+=20,optional&&(subSegmentScore+=-8),repeatable&&(subSegmentScore+=-20),".*"===re&&(subSegmentScore+=-50)}segmentScores.push(subSegmentScore)}score.push(segmentScores)}if(options.strict&&options.end){const i=score.length-1;score[i][score[i].length-1]+=.7000000000000001}options.strict||(pattern+="/?"),options.end?pattern+="$":options.strict&&(pattern+="(?:/|$)");const re=new RegExp(pattern,options.sensitive?"":"i");return{re:re,score:score,keys:keys,parse:function(path){const match=path.match(re),params={};if(!match)return null;for(let i=1;i<match.length;i++){const value=match[i]||"",key=keys[i-1];params[key.name]=value&&key.repeatable?value.split("/"):value}return params},stringify:function(params){let path="",avoidDuplicatedSlash=!1;for(const segment of segments){avoidDuplicatedSlash&&path.endsWith("/")||(path+="/"),avoidDuplicatedSlash=!1;for(const token of segment)if(0===token.type)path+=token.value;else if(1===token.type){const{value:value,repeatable:repeatable,optional:optional}=token,param=value in params?params[value]:"";if(isArray(param)&&!repeatable)throw new Error('Provided param "'.concat(value,'" is an array but it is not repeatable (* or + modifiers)'));const text=isArray(param)?param.join("/"):param;if(!text){if(!optional)throw new Error('Missing required param "'.concat(value,'"'));segment.length<2&&(path.endsWith("/")?path=path.slice(0,-1):avoidDuplicatedSlash=!0)}path+=text}}return path||"/"}}}(function(path){if(!path)return[[]];if("/"===path)return[[ROOT_TOKEN]];if(!path.startsWith("/"))throw new Error('Route paths should start with a "/": "'.concat(path,'" should be "/').concat(path,'".'));function crash(message){throw new Error("ERR (".concat(state,')/"').concat(buffer,'": ').concat(message))}let state=0,previousState=state;const tokens=[];let segment;function finalizeSegment(){segment&&tokens.push(segment),segment=[]}let char,i=0,buffer="",customRe="";function consumeBuffer(){buffer&&(0===state?segment.push({type:0,value:buffer}):1===state||2===state||3===state?(segment.length>1&&("*"===char||"+"===char)&&crash("A repeatable param (".concat(buffer,") must be alone in its segment. eg: '/:ids+.")),segment.push({type:1,value:buffer,regexp:customRe,repeatable:"*"===char||"+"===char,optional:"*"===char||"?"===char})):crash("Invalid state to consume buffer"),buffer="")}function addCharToBuffer(){buffer+=char}for(;i<path.length;)if(char=path[i++],"\\"!==char||2===state)switch(state){case 0:"/"===char?(buffer&&consumeBuffer(),finalizeSegment()):":"===char?(consumeBuffer(),state=1):addCharToBuffer();break;case 4:addCharToBuffer(),state=previousState;break;case 1:"("===char?state=2:VALID_PARAM_RE.test(char)?addCharToBuffer():(consumeBuffer(),state=0,"*"!==char&&"?"!==char&&"+"!==char&&i--);break;case 2:")"===char?"\\"==customRe[customRe.length-1]?customRe=customRe.slice(0,-1)+char:state=3:customRe+=char;break;case 3:consumeBuffer(),state=0,"*"!==char&&"?"!==char&&"+"!==char&&i--,customRe="";break;default:crash("Unknown state")}else previousState=state,state=4;return 2===state&&crash('Unfinished custom RegExp for param "'.concat(buffer,'"')),consumeBuffer(),finalizeSegment(),tokens}(record.path),options);{const existingKeys=new Set;for(const key of parser.keys)existingKeys.has(key.name)&&warn('Found duplicated params with name "'.concat(key.name,'" for path "').concat(record.path,'". Only the last one will be available on "$route.params".')),existingKeys.add(key.name)}const matcher=assign(parser,{record:record,parent:parent,children:[],alias:[]});return parent&&!matcher.record.aliasOf==!parent.record.aliasOf&&parent.children.push(matcher),matcher}function createRouterMatcher(routes,globalOptions){const matchers=[],matcherMap=new Map;function addRoute(record,parent,originalRecord){const isRootAdd=!originalRecord,mainNormalizedRecord=function(record){return{path:record.path,redirect:record.redirect,name:record.name,meta:record.meta||{},aliasOf:void 0,beforeEnter:record.beforeEnter,props:normalizeRecordProps(record),children:record.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in record?record.components||null:record.component&&{default:record.component}}}(record);!function(mainNormalizedRecord,parent){parent&&parent.record.name&&!mainNormalizedRecord.name&&!mainNormalizedRecord.path&&warn('The route named "'.concat(String(parent.record.name),"\" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning."))}(mainNormalizedRecord,parent),mainNormalizedRecord.aliasOf=originalRecord&&originalRecord.record;const options=mergeOptions(globalOptions,record),normalizedRecords=[mainNormalizedRecord];if("alias"in record){const aliases="string"==typeof record.alias?[record.alias]:record.alias;for(const alias of aliases)normalizedRecords.push(assign({},mainNormalizedRecord,{components:originalRecord?originalRecord.record.components:mainNormalizedRecord.components,path:alias,aliasOf:originalRecord?originalRecord.record:mainNormalizedRecord}))}let matcher,originalMatcher;for(const normalizedRecord of normalizedRecords){const{path:path}=normalizedRecord;if(parent&&"/"!==path[0]){const parentPath=parent.record.path,connectingSlash="/"===parentPath[parentPath.length-1]?"":"/";normalizedRecord.path=parent.record.path+(path&&connectingSlash+path)}if("*"===normalizedRecord.path)throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\nSee more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');if(matcher=createRouteRecordMatcher(normalizedRecord,parent,options),parent&&"/"===path[0]&&checkMissingParamsInAbsolutePath(matcher,parent),originalRecord?(originalRecord.alias.push(matcher),checkSameParams(originalRecord,matcher)):(originalMatcher=originalMatcher||matcher,originalMatcher!==matcher&&originalMatcher.alias.push(matcher),isRootAdd&&record.name&&!isAliasRecord(matcher)&&removeRoute(record.name)),mainNormalizedRecord.children){const children=mainNormalizedRecord.children;for(let i=0;i<children.length;i++)addRoute(children[i],matcher,originalRecord&&originalRecord.children[i])}originalRecord=originalRecord||matcher,(matcher.record.components&&Object.keys(matcher.record.components).length||matcher.record.name||matcher.record.redirect)&&insertMatcher(matcher)}return originalMatcher?()=>{removeRoute(originalMatcher)}:noop}function removeRoute(matcherRef){if(isRouteName(matcherRef)){const matcher=matcherMap.get(matcherRef);matcher&&(matcherMap.delete(matcherRef),matchers.splice(matchers.indexOf(matcher),1),matcher.children.forEach(removeRoute),matcher.alias.forEach(removeRoute))}else{const index=matchers.indexOf(matcherRef);index>-1&&(matchers.splice(index,1),matcherRef.record.name&&matcherMap.delete(matcherRef.record.name),matcherRef.children.forEach(removeRoute),matcherRef.alias.forEach(removeRoute))}}function insertMatcher(matcher){let i=0;for(;i<matchers.length&&comparePathParserScore(matcher,matchers[i])>=0&&(matcher.record.path!==matchers[i].record.path||!isRecordChildOf(matcher,matchers[i]));)i++;matchers.splice(i,0,matcher),matcher.record.name&&!isAliasRecord(matcher)&&matcherMap.set(matcher.record.name,matcher)}return globalOptions=mergeOptions({strict:!1,end:!0,sensitive:!1},globalOptions),routes.forEach((route=>addRoute(route))),{addRoute:addRoute,resolve:function(location,currentLocation){let matcher,path,name,params={};if("name"in location&&location.name){if(matcher=matcherMap.get(location.name),!matcher)throw createRouterError(1,{location:location});{const invalidParams=Object.keys(location.params||{}).filter((paramName=>!matcher.keys.find((k=>k.name===paramName))));invalidParams.length&&warn('Discarded invalid param(s) "'.concat(invalidParams.join('", "'),'" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.'))}name=matcher.record.name,params=assign(paramsFromLocation(currentLocation.params,matcher.keys.filter((k=>!k.optional)).map((k=>k.name))),location.params&&paramsFromLocation(location.params,matcher.keys.map((k=>k.name)))),path=matcher.stringify(params)}else if("path"in location)path=location.path,path.startsWith("/")||warn('The Matcher cannot resolve relative paths but received "'.concat(path,'". Unless you directly called `matcher.resolve("').concat(path,'")`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.')),matcher=matchers.find((m=>m.re.test(path))),matcher&&(params=matcher.parse(path),name=matcher.record.name);else{if(matcher=currentLocation.name?matcherMap.get(currentLocation.name):matchers.find((m=>m.re.test(currentLocation.path))),!matcher)throw createRouterError(1,{location:location,currentLocation:currentLocation});name=matcher.record.name,params=assign({},currentLocation.params,location.params),path=matcher.stringify(params)}const matched=[];let parentMatcher=matcher;for(;parentMatcher;)matched.unshift(parentMatcher.record),parentMatcher=parentMatcher.parent;return{name:name,path:path,params:params,matched:matched,meta:mergeMetaFields(matched)}},removeRoute:removeRoute,getRoutes:function(){return matchers},getRecordMatcher:function(name){return matcherMap.get(name)}}}function paramsFromLocation(params,keys){const newParams={};for(const key of keys)key in params&&(newParams[key]=params[key]);return newParams}function normalizeRecordProps(record){const propsObject={},props=record.props||!1;if("component"in record)propsObject.default=props;else for(const name in record.components)propsObject[name]="object"==typeof props?props[name]:props;return propsObject}function isAliasRecord(record){for(;record;){if(record.record.aliasOf)return!0;record=record.parent}return!1}function mergeMetaFields(matched){return matched.reduce(((meta,record)=>assign(meta,record.meta)),{})}function mergeOptions(defaults,partialOptions){const options={};for(const key in defaults)options[key]=key in partialOptions?partialOptions[key]:defaults[key];return options}function isSameParam(a,b){return a.name===b.name&&a.optional===b.optional&&a.repeatable===b.repeatable}function checkSameParams(a,b){for(const key of a.keys)if(!key.optional&&!b.keys.find(isSameParam.bind(null,key)))return warn('Alias "'.concat(b.record.path,'" and the original record: "').concat(a.record.path,'" must have the exact same param named "').concat(key.name,'"'));for(const key of b.keys)if(!key.optional&&!a.keys.find(isSameParam.bind(null,key)))return warn('Alias "'.concat(b.record.path,'" and the original record: "').concat(a.record.path,'" must have the exact same param named "').concat(key.name,'"'))}function checkMissingParamsInAbsolutePath(record,parent){for(const key of parent.keys)if(!record.keys.find(isSameParam.bind(null,key)))return warn('Absolute path "'.concat(record.record.path,'" must have the exact same param named "').concat(key.name,'" as its parent "').concat(parent.record.path,'".'))}function isRecordChildOf(record,parent){return parent.children.some((child=>child===record||isRecordChildOf(record,child)))}const HASH_RE=/#/g,AMPERSAND_RE=/&/g,SLASH_RE=/\//g,EQUAL_RE=/=/g,IM_RE=/\?/g,PLUS_RE=/\+/g,ENC_BRACKET_OPEN_RE=/%5B/g,ENC_BRACKET_CLOSE_RE=/%5D/g,ENC_CARET_RE=/%5E/g,ENC_BACKTICK_RE=/%60/g,ENC_CURLY_OPEN_RE=/%7B/g,ENC_PIPE_RE=/%7C/g,ENC_CURLY_CLOSE_RE=/%7D/g,ENC_SPACE_RE=/%20/g;function commonEncode(text){return encodeURI(""+text).replace(ENC_PIPE_RE,"|").replace(ENC_BRACKET_OPEN_RE,"[").replace(ENC_BRACKET_CLOSE_RE,"]")}function encodeQueryValue(text){return commonEncode(text).replace(PLUS_RE,"%2B").replace(ENC_SPACE_RE,"+").replace(HASH_RE,"%23").replace(AMPERSAND_RE,"%26").replace(ENC_BACKTICK_RE,"`").replace(ENC_CURLY_OPEN_RE,"{").replace(ENC_CURLY_CLOSE_RE,"}").replace(ENC_CARET_RE,"^")}function encodeParam(text){return null==text?"":function(text){return commonEncode(text).replace(HASH_RE,"%23").replace(IM_RE,"%3F")}(text).replace(SLASH_RE,"%2F")}function decode(text){try{return decodeURIComponent(""+text)}catch(err){warn('Error decoding "'.concat(text,'". Using original value'))}return""+text}function parseQuery(search){const query={};if(""===search||"?"===search)return query;const searchParams=("?"===search[0]?search.slice(1):search).split("&");for(let i=0;i<searchParams.length;++i){const searchParam=searchParams[i].replace(PLUS_RE," "),eqPos=searchParam.indexOf("="),key=decode(eqPos<0?searchParam:searchParam.slice(0,eqPos)),value=eqPos<0?null:decode(searchParam.slice(eqPos+1));if(key in query){let currentValue=query[key];isArray(currentValue)||(currentValue=query[key]=[currentValue]),currentValue.push(value)}else query[key]=value}return query}function stringifyQuery(query){let search="";for(let key in query){const value=query[key];if(key=encodeQueryValue(key).replace(EQUAL_RE,"%3D"),null==value){void 0!==value&&(search+=(search.length?"&":"")+key);continue}(isArray(value)?value.map((v=>v&&encodeQueryValue(v))):[value&&encodeQueryValue(value)]).forEach((value=>{void 0!==value&&(search+=(search.length?"&":"")+key,null!=value&&(search+="="+value))}))}return search}function normalizeQuery(query){const normalizedQuery={};for(const key in query){const value=query[key];void 0!==value&&(normalizedQuery[key]=isArray(value)?value.map((v=>null==v?null:""+v)):null==value?value:""+value)}return normalizedQuery}const matchedRouteKey=Symbol("router view location matched"),viewDepthKey=Symbol("router view depth"),routerKey=Symbol("router"),routeLocationKey=Symbol("route location"),routerViewLocationKey=Symbol("router view location");function useCallbacks(){let handlers=[];return{add:function(handler){return handlers.push(handler),()=>{const i=handlers.indexOf(handler);i>-1&&handlers.splice(i,1)}},list:()=>handlers.slice(),reset:function(){handlers=[]}}}function registerGuard(record,name,guard){const removeFromList=()=>{record[name].delete(guard)};vue.onUnmounted(removeFromList),vue.onDeactivated(removeFromList),vue.onActivated((()=>{record[name].add(guard)})),record[name].add(guard)}function guardToPromiseFn(guard,to,from,record,name){const enterCallbackArray=record&&(record.enterCallbacks[name]=record.enterCallbacks[name]||[]);return()=>new Promise(((resolve,reject)=>{const next=valid=>{var route;!1===valid?reject(createRouterError(4,{from:from,to:to})):valid instanceof Error?reject(valid):"string"==typeof(route=valid)||route&&"object"==typeof route?reject(createRouterError(2,{from:to,to:valid})):(enterCallbackArray&&record.enterCallbacks[name]===enterCallbackArray&&"function"==typeof valid&&enterCallbackArray.push(valid),resolve())},guardReturn=guard.call(record&&record.instances[name],to,from,function(next,to,from){let called=0;return function(){1==called++&&warn('The "next" callback was called more than once in one navigation guard when going from "'.concat(from.fullPath,'" to "').concat(to.fullPath,'". It should be called exactly one time in each navigation guard. This will fail in production.')),next._called=!0,1===called&&next.apply(null,arguments)}}(next,to,from));let guardCall=Promise.resolve(guardReturn);if(guard.length<3&&(guardCall=guardCall.then(next)),guard.length>2){const message='The "next" callback was never called inside of '.concat(guard.name?'"'+guard.name+'"':"",":\n").concat(guard.toString(),'\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.');if("object"==typeof guardReturn&&"then"in guardReturn)guardCall=guardCall.then((resolvedValue=>next._called?resolvedValue:(warn(message),Promise.reject(new Error("Invalid navigation guard")))));else if(void 0!==guardReturn&&!next._called)return warn(message),void reject(new Error("Invalid navigation guard"))}guardCall.catch((err=>reject(err)))}))}function extractComponentsGuards(matched,guardType,to,from){const guards=[];for(const record of matched){record.components||record.children.length||warn('Record with path "'.concat(record.path,'" is either missing a "component(s)"')+' or "children" property.');for(const name in record.components){let rawComponent=record.components[name];if(!rawComponent||"object"!=typeof rawComponent&&"function"!=typeof rawComponent)throw warn('Component "'.concat(name,'" in record with path "').concat(record.path,'" is not')+' a valid component. Received "'.concat(String(rawComponent),'".')),new Error("Invalid route component");if("then"in rawComponent){warn('Component "'.concat(name,'" in record with path "').concat(record.path,'" is a ')+"Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\" ? This will break in production if not fixed.");const promise=rawComponent;rawComponent=()=>promise}else rawComponent.__asyncLoader&&!rawComponent.__warnedDefineAsync&&(rawComponent.__warnedDefineAsync=!0,warn('Component "'.concat(name,'" in record with path "').concat(record.path,'" is defined ')+'using "defineAsyncComponent()". Write "() => import(\'./MyPage.vue\')" instead of "defineAsyncComponent(() => import(\'./MyPage.vue\'))".'));if("beforeRouteEnter"===guardType||record.instances[name])if("object"==typeof(component=rawComponent)||"displayName"in component||"props"in component||"__vccOpts"in component){const guard=(rawComponent.__vccOpts||rawComponent)[guardType];guard&&guards.push(guardToPromiseFn(guard,to,from,record,name))}else{let componentPromise=rawComponent();"catch"in componentPromise||(warn('Component "'.concat(name,'" in record with path "').concat(record.path,'" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.')),componentPromise=Promise.resolve(componentPromise)),guards.push((()=>componentPromise.then((resolved=>{if(!resolved)return Promise.reject(new Error("Couldn't resolve component \"".concat(name,'" at "').concat(record.path,'"')));const resolvedComponent=isESModule(resolved)?resolved.default:resolved;record.components[name]=resolvedComponent;const guard=(resolvedComponent.__vccOpts||resolvedComponent)[guardType];return guard&&guardToPromiseFn(guard,to,from,record,name)()}))))}}}var component;return guards}function useLink(props){const router=vue.inject(routerKey),currentRoute=vue.inject(routeLocationKey),route=vue.computed((()=>router.resolve(vue.unref(props.to)))),activeRecordIndex=vue.computed((()=>{const{matched:matched}=route.value,{length:length}=matched,routeMatched=matched[length-1],currentMatched=currentRoute.matched;if(!routeMatched||!currentMatched.length)return-1;const index=currentMatched.findIndex(isSameRouteRecord.bind(null,routeMatched));if(index>-1)return index;const parentRecordPath=getOriginalPath(matched[length-2]);return length>1&&getOriginalPath(routeMatched)===parentRecordPath&&currentMatched[currentMatched.length-1].path!==parentRecordPath?currentMatched.findIndex(isSameRouteRecord.bind(null,matched[length-2])):index})),isActive=vue.computed((()=>activeRecordIndex.value>-1&&function(outer,inner){for(const key in inner){const innerValue=inner[key],outerValue=outer[key];if("string"==typeof innerValue){if(innerValue!==outerValue)return!1}else if(!isArray(outerValue)||outerValue.length!==innerValue.length||innerValue.some(((value,i)=>value!==outerValue[i])))return!1}return!0}(currentRoute.params,route.value.params))),isExactActive=vue.computed((()=>activeRecordIndex.value>-1&&activeRecordIndex.value===currentRoute.matched.length-1&&isSameRouteLocationParams(currentRoute.params,route.value.params)));if(isBrowser){const instance=vue.getCurrentInstance();if(instance){const linkContextDevtools={route:route.value,isActive:isActive.value,isExactActive:isExactActive.value};instance.__vrl_devtools=instance.__vrl_devtools||[],instance.__vrl_devtools.push(linkContextDevtools),vue.watchEffect((()=>{linkContextDevtools.route=route.value,linkContextDevtools.isActive=isActive.value,linkContextDevtools.isExactActive=isExactActive.value}),{flush:"post"})}}return{route:route,href:vue.computed((()=>route.value.href)),isActive:isActive,isExactActive:isExactActive,navigate:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return guardEvent(e)?router[vue.unref(props.replace)?"replace":"push"](vue.unref(props.to)).catch(noop):Promise.resolve()}}}const RouterLink=vue.defineComponent({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:useLink,setup(props,_ref8){let{slots:slots}=_ref8;const link=vue.reactive(useLink(props)),{options:options}=vue.inject(routerKey),elClass=vue.computed((()=>({[getLinkClass(props.activeClass,options.linkActiveClass,"router-link-active")]:link.isActive,[getLinkClass(props.exactActiveClass,options.linkExactActiveClass,"router-link-exact-active")]:link.isExactActive})));return()=>{const children=slots.default&&slots.default(link);return props.custom?children:vue.h("a",{"aria-current":link.isExactActive?props.ariaCurrentValue:null,href:link.href,onClick:link.navigate,class:elClass.value},children)}}});function guardEvent(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){const target=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(target))return}return e.preventDefault&&e.preventDefault(),!0}}function getOriginalPath(record){return record?record.aliasOf?record.aliasOf.path:record.path:""}const getLinkClass=(propClass,globalClass,defaultClass)=>null!=propClass?propClass:null!=globalClass?globalClass:defaultClass;function normalizeSlot(slot,data){if(!slot)return null;const slotContent=slot(data);return 1===slotContent.length?slotContent[0]:slotContent}const RouterView=vue.defineComponent({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(props,_ref9){let{attrs:attrs,slots:slots}=_ref9;!function(){const instance=vue.getCurrentInstance(),parentName=instance.parent&&instance.parent.type.name,parentSubTreeType=instance.parent&&instance.parent.subTree&&instance.parent.subTree.type;if(parentName&&("KeepAlive"===parentName||parentName.includes("Transition"))&&"object"==typeof parentSubTreeType&&"RouterView"===parentSubTreeType.name){const comp="KeepAlive"===parentName?"keep-alive":"transition";warn('<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot="{ Component }">\n'+"  <".concat(comp,">\n")+'    <component :is="Component" />\n'+"  </".concat(comp,">\n")+"</router-view>")}}();const injectedRoute=vue.inject(routerViewLocationKey),routeToDisplay=vue.computed((()=>props.route||injectedRoute.value)),injectedDepth=vue.inject(viewDepthKey,0),depth=vue.computed((()=>{let initialDepth=vue.unref(injectedDepth);const{matched:matched}=routeToDisplay.value;let matchedRoute;for(;(matchedRoute=matched[initialDepth])&&!matchedRoute.components;)initialDepth++;return initialDepth})),matchedRouteRef=vue.computed((()=>routeToDisplay.value.matched[depth.value]));vue.provide(viewDepthKey,vue.computed((()=>depth.value+1))),vue.provide(matchedRouteKey,matchedRouteRef),vue.provide(routerViewLocationKey,routeToDisplay);const viewRef=vue.ref();return vue.watch((()=>[viewRef.value,matchedRouteRef.value,props.name]),((_ref10,_ref11)=>{let[instance,to,name]=_ref10,[oldInstance,from,oldName]=_ref11;to&&(to.instances[name]=instance,from&&from!==to&&instance&&instance===oldInstance&&(to.leaveGuards.size||(to.leaveGuards=from.leaveGuards),to.updateGuards.size||(to.updateGuards=from.updateGuards))),!instance||!to||from&&isSameRouteRecord(to,from)&&oldInstance||(to.enterCallbacks[name]||[]).forEach((callback=>callback(instance)))}),{flush:"post"}),()=>{const route=routeToDisplay.value,currentName=props.name,matchedRoute=matchedRouteRef.value,ViewComponent=matchedRoute&&matchedRoute.components[currentName];if(!ViewComponent)return normalizeSlot(slots.default,{Component:ViewComponent,route:route});const routePropsOption=matchedRoute.props[currentName],routeProps=routePropsOption?!0===routePropsOption?route.params:"function"==typeof routePropsOption?routePropsOption(route):routePropsOption:null,component=vue.h(ViewComponent,assign({},routeProps,attrs,{onVnodeUnmounted:vnode=>{vnode.component.isUnmounted&&(matchedRoute.instances[currentName]=null)},ref:viewRef}));if(isBrowser&&component.ref){const info={depth:depth.value,name:matchedRoute.name,path:matchedRoute.path,meta:matchedRoute.meta};(isArray(component.ref)?component.ref.map((r=>r.i)):[component.ref.i]).forEach((instance=>{instance.__vrv_devtools=info}))}return normalizeSlot(slots.default,{Component:component,route:route})||component}}});function getTarget(){return"undefined"!=typeof navigator&&"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}}const isProxyAvailable="function"==typeof Proxy;let supported,perf;function now(){return void 0!==supported||("undefined"!=typeof window&&window.performance?(supported=!0,perf=window.performance):"undefined"!=typeof global&&(null===(_a=global.perf_hooks)||void 0===_a?void 0:_a.performance)?(supported=!0,perf=global.perf_hooks.performance):supported=!1),supported?perf.now():Date.now();var _a}class ApiProxy{constructor(plugin,hook){var _this=this;this.target=null,this.targetQueue=[],this.onQueue=[],this.plugin=plugin,this.hook=hook;const defaultSettings={};if(plugin.settings)for(const id in plugin.settings){const item=plugin.settings[id];defaultSettings[id]=item.defaultValue}const localSettingsSaveId="__vue-devtools-plugin-settings__".concat(plugin.id);let currentSettings=Object.assign({},defaultSettings);try{const raw=localStorage.getItem(localSettingsSaveId),data=JSON.parse(raw);Object.assign(currentSettings,data)}catch(e){}this.fallbacks={getSettings:()=>currentSettings,setSettings(value){try{localStorage.setItem(localSettingsSaveId,JSON.stringify(value))}catch(e){}currentSettings=value},now:()=>now()},hook&&hook.on("plugin:settings:set",((pluginId,value)=>{pluginId===this.plugin.id&&this.fallbacks.setSettings(value)})),this.proxiedOn=new Proxy({},{get:(_target,prop)=>this.target?this.target.on[prop]:function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];_this.onQueue.push({method:prop,args:args})}}),this.proxiedTarget=new Proxy({},{get:(_target,prop)=>this.target?this.target[prop]:"on"===prop?this.proxiedOn:Object.keys(this.fallbacks).includes(prop)?function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return _this.targetQueue.push({method:prop,args:args,resolve:()=>{}}),_this.fallbacks[prop](...args)}:function(){for(var _len3=arguments.length,args=new Array(_len3),_key3=0;_key3<_len3;_key3++)args[_key3]=arguments[_key3];return new Promise((resolve=>{_this.targetQueue.push({method:prop,args:args,resolve:resolve})}))}})}async setRealTarget(target){this.target=target;for(const item of this.onQueue)this.target.on[item.method](...item.args);for(const item of this.targetQueue)item.resolve(await this.target[item.method](...item.args))}}function setupDevtoolsPlugin(pluginDescriptor,setupFn){const descriptor=pluginDescriptor,target=getTarget(),hook=getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__,enableProxy=isProxyAvailable&&descriptor.enableEarlyProxy;if(!hook||!target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__&&enableProxy){const proxy=enableProxy?new ApiProxy(descriptor,hook):null;(target.__VUE_DEVTOOLS_PLUGINS__=target.__VUE_DEVTOOLS_PLUGINS__||[]).push({pluginDescriptor:descriptor,setupFn:setupFn,proxy:proxy}),proxy&&setupFn(proxy.proxiedTarget)}else hook.emit("devtools-plugin:setup",pluginDescriptor,setupFn)}function formatRouteLocation(routeLocation,tooltip){const copy=assign({},routeLocation,{matched:routeLocation.matched.map((matched=>function(obj,keys){const ret={};for(const key in obj)keys.includes(key)||(ret[key]=obj[key]);return ret}(matched,["instances","children","aliasOf"])))});return{_custom:{type:null,readOnly:!0,display:routeLocation.fullPath,tooltip:tooltip,value:copy}}}function formatDisplay(display){return{_custom:{display:display}}}let routerId=0;function addDevtools(app,router,matcher){if(router.__hasDevtools)return;router.__hasDevtools=!0;const id=routerId++;setupDevtoolsPlugin({id:"org.vuejs.router"+(id?"."+id:""),label:"Vue Router",packageName:"vue-router",homepage:"https://router.vuejs.org",logo:"https://router.vuejs.org/logo.png",componentStateTypes:["Routing"],app:app},(api=>{"function"!=typeof api.now&&console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),api.on.inspectComponent(((payload,ctx)=>{payload.instanceData&&payload.instanceData.state.push({type:"Routing",key:"$route",editable:!1,value:formatRouteLocation(router.currentRoute.value,"Current Route")})})),api.on.visitComponentTree((_ref12=>{let{treeNode:node,componentInstance:componentInstance}=_ref12;if(componentInstance.__vrv_devtools){const info=componentInstance.__vrv_devtools;node.tags.push({label:(info.name?"".concat(info.name.toString(),": "):"")+info.path,textColor:0,tooltip:"This component is rendered by &lt;router-view&gt;",backgroundColor:PINK_500})}isArray(componentInstance.__vrl_devtools)&&(componentInstance.__devtoolsApi=api,componentInstance.__vrl_devtools.forEach((devtoolsData=>{let backgroundColor=ORANGE_400,tooltip="";devtoolsData.isExactActive?(backgroundColor=LIME_500,tooltip="This is exactly active"):devtoolsData.isActive&&(backgroundColor=BLUE_600,tooltip="This link is active"),node.tags.push({label:devtoolsData.route.path,textColor:0,tooltip:tooltip,backgroundColor:backgroundColor})})))})),vue.watch(router.currentRoute,(()=>{refreshRoutesView(),api.notifyComponentUpdate(),api.sendInspectorTree(routerInspectorId),api.sendInspectorState(routerInspectorId)}));const navigationsLayerId="router:navigations:"+id;api.addTimelineLayer({id:navigationsLayerId,label:"Router".concat(id?" "+id:""," Navigations"),color:4237508}),router.onError(((error,to)=>{api.addTimelineEvent({layerId:navigationsLayerId,event:{title:"Error during Navigation",subtitle:to.fullPath,logType:"error",time:api.now(),data:{error:error},groupId:to.meta.__navigationId}})}));let navigationId=0;router.beforeEach(((to,from)=>{const data={guard:formatDisplay("beforeEach"),from:formatRouteLocation(from,"Current Location during this navigation"),to:formatRouteLocation(to,"Target location")};Object.defineProperty(to.meta,"__navigationId",{value:navigationId++}),api.addTimelineEvent({layerId:navigationsLayerId,event:{time:api.now(),title:"Start of navigation",subtitle:to.fullPath,data:data,groupId:to.meta.__navigationId}})})),router.afterEach(((to,from,failure)=>{const data={guard:formatDisplay("afterEach")};failure?(data.failure={_custom:{type:Error,readOnly:!0,display:failure?failure.message:"",tooltip:"Navigation Failure",value:failure}},data.status=formatDisplay("❌")):data.status=formatDisplay("✅"),data.from=formatRouteLocation(from,"Current Location during this navigation"),data.to=formatRouteLocation(to,"Target location"),api.addTimelineEvent({layerId:navigationsLayerId,event:{title:"End of navigation",subtitle:to.fullPath,time:api.now(),data:data,logType:failure?"warning":"default",groupId:to.meta.__navigationId}})}));const routerInspectorId="router-inspector:"+id;function refreshRoutesView(){if(!activeRoutesPayload)return;const payload=activeRoutesPayload;let routes=matcher.getRoutes().filter((route=>!route.parent||!route.parent.record.components));routes.forEach(resetMatchStateOnRouteRecord),payload.filter&&(routes=routes.filter((route=>isRouteMatching(route,payload.filter.toLowerCase())))),routes.forEach((route=>markRouteRecordActive(route,router.currentRoute.value))),payload.rootNodes=routes.map(formatRouteRecordForInspector)}let activeRoutesPayload;api.addInspector({id:routerInspectorId,label:"Routes"+(id?" "+id:""),icon:"book",treeFilterPlaceholder:"Search routes"}),api.on.getInspectorTree((payload=>{activeRoutesPayload=payload,payload.app===app&&payload.inspectorId===routerInspectorId&&refreshRoutesView()})),api.on.getInspectorState((payload=>{if(payload.app===app&&payload.inspectorId===routerInspectorId){const route=matcher.getRoutes().find((route=>route.record.__vd_id===payload.nodeId));route&&(payload.state={options:formatRouteRecordMatcherForStateInspector(route)})}})),api.sendInspectorTree(routerInspectorId),api.sendInspectorState(routerInspectorId)}))}function formatRouteRecordMatcherForStateInspector(route){const{record:record}=route,fields=[{editable:!1,key:"path",value:record.path}];return null!=record.name&&fields.push({editable:!1,key:"name",value:record.name}),fields.push({editable:!1,key:"regexp",value:route.re}),route.keys.length&&fields.push({editable:!1,key:"keys",value:{_custom:{type:null,readOnly:!0,display:route.keys.map((key=>"".concat(key.name).concat(function(key){return key.optional?key.repeatable?"*":"?":key.repeatable?"+":""}(key)))).join(" "),tooltip:"Param keys",value:route.keys}}}),null!=record.redirect&&fields.push({editable:!1,key:"redirect",value:record.redirect}),route.alias.length&&fields.push({editable:!1,key:"aliases",value:route.alias.map((alias=>alias.record.path))}),Object.keys(route.record.meta).length&&fields.push({editable:!1,key:"meta",value:route.record.meta}),fields.push({key:"score",editable:!1,value:{_custom:{type:null,readOnly:!0,display:route.score.map((score=>score.join(", "))).join(" | "),tooltip:"Score used to sort routes",value:route.score}}}),fields}const PINK_500=15485081,BLUE_600=2450411,LIME_500=8702998,ORANGE_400=16486972;function formatRouteRecordForInspector(route){const tags=[],{record:record}=route;null!=record.name&&tags.push({label:String(record.name),textColor:0,backgroundColor:2282478}),record.aliasOf&&tags.push({label:"alias",textColor:0,backgroundColor:ORANGE_400}),route.__vd_match&&tags.push({label:"matches",textColor:0,backgroundColor:PINK_500}),route.__vd_exactActive&&tags.push({label:"exact",textColor:0,backgroundColor:LIME_500}),route.__vd_active&&tags.push({label:"active",textColor:0,backgroundColor:BLUE_600}),record.redirect&&tags.push({label:"string"==typeof record.redirect?"redirect: ".concat(record.redirect):"redirects",textColor:16777215,backgroundColor:6710886});let id=record.__vd_id;return null==id&&(id=String(routeRecordId++),record.__vd_id=id),{id:id,label:record.path,tags:tags,children:route.children.map(formatRouteRecordForInspector)}}let routeRecordId=0;const EXTRACT_REGEXP_RE=/^\/(.*)\/([a-z]*)$/;function markRouteRecordActive(route,currentRoute){const isExactActive=currentRoute.matched.length&&isSameRouteRecord(currentRoute.matched[currentRoute.matched.length-1],route.record);route.__vd_exactActive=route.__vd_active=isExactActive,isExactActive||(route.__vd_active=currentRoute.matched.some((match=>isSameRouteRecord(match,route.record)))),route.children.forEach((childRoute=>markRouteRecordActive(childRoute,currentRoute)))}function resetMatchStateOnRouteRecord(route){route.__vd_match=!1,route.children.forEach(resetMatchStateOnRouteRecord)}function isRouteMatching(route,filter){const found=String(route.re).match(EXTRACT_REGEXP_RE);if(route.__vd_match=!1,!found||found.length<3)return!1;if(new RegExp(found[1].replace(/\$$/,""),found[2]).test(filter))return route.children.forEach((child=>isRouteMatching(child,filter))),("/"!==route.record.path||"/"===filter)&&(route.__vd_match=route.re.test(filter),!0);const path=route.record.path.toLowerCase(),decodedPath=decode(path);return!(filter.startsWith("/")||!decodedPath.includes(filter)&&!path.includes(filter))||(!(!decodedPath.startsWith(filter)&&!path.startsWith(filter))||(!(!route.record.name||!String(route.record.name).includes(filter))||route.children.some((child=>isRouteMatching(child,filter)))))}return exports.RouterLink=RouterLink,exports.RouterView=RouterView,exports.START_LOCATION=START_LOCATION_NORMALIZED,exports.createMemoryHistory=function(){let base=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",listeners=[],queue=[""],position=0;function setLocation(location){position++,position!==queue.length&&queue.splice(position),queue.push(location)}function triggerListeners(to,from,_ref2){let{direction:direction,delta:delta}=_ref2;const info={direction:direction,delta:delta,type:NavigationType.pop};for(const callback of listeners)callback(to,from,info)}base=normalizeBase(base);const routerHistory={location:"",state:{},base:base,createHref:createHref.bind(null,base),replace(to){queue.splice(position--,1),setLocation(to)},push(to,data){setLocation(to)},listen:callback=>(listeners.push(callback),()=>{const index=listeners.indexOf(callback);index>-1&&listeners.splice(index,1)}),destroy(){listeners=[],queue=[""],position=0},go(delta){let shouldTrigger=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const from=this.location,direction=delta<0?NavigationDirection.back:NavigationDirection.forward;position=Math.max(0,Math.min(position+delta,queue.length-1)),shouldTrigger&&triggerListeners(this.location,from,{direction:direction,delta:delta})}};return Object.defineProperty(routerHistory,"location",{enumerable:!0,get:()=>queue[position]}),routerHistory},exports.createRouter=function(options){const matcher=createRouterMatcher(options.routes,options),parseQuery$1=options.parseQuery||parseQuery,stringifyQuery$1=options.stringifyQuery||stringifyQuery,routerHistory=options.history;if(!routerHistory)throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');const beforeGuards=useCallbacks(),beforeResolveGuards=useCallbacks(),afterGuards=useCallbacks(),currentRoute=vue.shallowRef(START_LOCATION_NORMALIZED);let pendingLocation=START_LOCATION_NORMALIZED;isBrowser&&options.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const normalizeParams=applyToParams.bind(null,(paramValue=>""+paramValue)),encodeParams=applyToParams.bind(null,encodeParam),decodeParams=applyToParams.bind(null,decode);function resolve(rawLocation,currentLocation){if(currentLocation=assign({},currentLocation||currentRoute.value),"string"==typeof rawLocation){const locationNormalized=parseURL(parseQuery$1,rawLocation,currentLocation.path),matchedRoute=matcher.resolve({path:locationNormalized.path},currentLocation),href=routerHistory.createHref(locationNormalized.fullPath);return href.startsWith("//")?warn('Location "'.concat(rawLocation,'" resolved to "').concat(href,'". A resolved location cannot start with multiple slashes.')):matchedRoute.matched.length||warn('No match found for location with path "'.concat(rawLocation,'"')),assign(locationNormalized,matchedRoute,{params:decodeParams(matchedRoute.params),hash:decode(locationNormalized.hash),redirectedFrom:void 0,href:href})}let matcherLocation;if("path"in rawLocation)"params"in rawLocation&&!("name"in rawLocation)&&Object.keys(rawLocation.params).length&&warn('Path "'.concat(rawLocation.path,'" was passed with params but they will be ignored. Use a named route alongside params instead.')),matcherLocation=assign({},rawLocation,{path:parseURL(parseQuery$1,rawLocation.path,currentLocation.path).path});else{const targetParams=assign({},rawLocation.params);for(const key in targetParams)null==targetParams[key]&&delete targetParams[key];matcherLocation=assign({},rawLocation,{params:encodeParams(targetParams)}),currentLocation.params=encodeParams(currentLocation.params)}const matchedRoute=matcher.resolve(matcherLocation,currentLocation),hash=rawLocation.hash||"";hash&&!hash.startsWith("#")&&warn('A `hash` should always start with the character "#". Replace "'.concat(hash,'" with "#').concat(hash,'".')),matchedRoute.params=normalizeParams(decodeParams(matchedRoute.params));const fullPath=function(stringifyQuery,location){const query=location.query?stringifyQuery(location.query):"";return location.path+(query&&"?")+query+(location.hash||"")}(stringifyQuery$1,assign({},rawLocation,{hash:(text=hash,commonEncode(text).replace(ENC_CURLY_OPEN_RE,"{").replace(ENC_CURLY_CLOSE_RE,"}").replace(ENC_CARET_RE,"^")),path:matchedRoute.path}));var text;const href=routerHistory.createHref(fullPath);return href.startsWith("//")?warn('Location "'.concat(rawLocation,'" resolved to "').concat(href,'". A resolved location cannot start with multiple slashes.')):matchedRoute.matched.length||warn('No match found for location with path "'.concat("path"in rawLocation?rawLocation.path:rawLocation,'"')),assign({fullPath:fullPath,hash:hash,query:stringifyQuery$1===stringifyQuery?normalizeQuery(rawLocation.query):rawLocation.query||{}},matchedRoute,{redirectedFrom:void 0,href:href})}function locationAsObject(to){return"string"==typeof to?parseURL(parseQuery$1,to,currentRoute.value.path):assign({},to)}function checkCanceledNavigation(to,from){if(pendingLocation!==to)return createRouterError(8,{from:from,to:to})}function push(to){return pushWithRedirect(to)}function handleRedirectRecord(to){const lastMatched=to.matched[to.matched.length-1];if(lastMatched&&lastMatched.redirect){const{redirect:redirect}=lastMatched;let newTargetLocation="function"==typeof redirect?redirect(to):redirect;if("string"==typeof newTargetLocation&&(newTargetLocation=newTargetLocation.includes("?")||newTargetLocation.includes("#")?newTargetLocation=locationAsObject(newTargetLocation):{path:newTargetLocation},newTargetLocation.params={}),!("path"in newTargetLocation)&&!("name"in newTargetLocation))throw warn("Invalid redirect found:\n".concat(JSON.stringify(newTargetLocation,null,2),'\n when navigating to "').concat(to.fullPath,'". A redirect must contain a name or path. This will break in production.')),new Error("Invalid redirect");return assign({query:to.query,hash:to.hash,params:"path"in newTargetLocation?{}:to.params},newTargetLocation)}}function pushWithRedirect(to,redirectedFrom){const targetLocation=pendingLocation=resolve(to),from=currentRoute.value,data=to.state,force=to.force,replace=!0===to.replace,shouldRedirect=handleRedirectRecord(targetLocation);if(shouldRedirect)return pushWithRedirect(assign(locationAsObject(shouldRedirect),{state:"object"==typeof shouldRedirect?assign({},data,shouldRedirect.state):data,force:force,replace:replace}),redirectedFrom||targetLocation);const toLocation=targetLocation;let failure;return toLocation.redirectedFrom=redirectedFrom,!force&&isSameRouteLocation(stringifyQuery$1,from,targetLocation)&&(failure=createRouterError(16,{to:toLocation,from:from}),handleScroll(from,from,!0,!1)),(failure?Promise.resolve(failure):navigate(toLocation,from)).catch((error=>isNavigationFailure(error)?isNavigationFailure(error,2)?error:markAsReady(error):triggerError(error,toLocation,from))).then((failure=>{if(failure){if(isNavigationFailure(failure,2))return isSameRouteLocation(stringifyQuery$1,resolve(failure.to),toLocation)&&redirectedFrom&&(redirectedFrom._count=redirectedFrom._count?redirectedFrom._count+1:1)>30?(warn('Detected a possibly infinite redirection in a navigation guard when going from "'.concat(from.fullPath,'" to "').concat(toLocation.fullPath,'". Aborting to avoid a Stack Overflow.\n Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.')),Promise.reject(new Error("Infinite redirect in navigation guard"))):pushWithRedirect(assign({replace:replace},locationAsObject(failure.to),{state:"object"==typeof failure.to?assign({},data,failure.to.state):data,force:force}),redirectedFrom||toLocation)}else failure=finalizeNavigation(toLocation,from,!0,replace,data);return triggerAfterEach(toLocation,from,failure),failure}))}function checkCanceledNavigationAndReject(to,from){const error=checkCanceledNavigation(to,from);return error?Promise.reject(error):Promise.resolve()}function runWithContext(fn){const app=installedApps.values().next().value;return app&&"function"==typeof app.runWithContext?app.runWithContext(fn):fn()}function navigate(to,from){let guards;const[leavingRecords,updatingRecords,enteringRecords]=function(to,from){const leavingRecords=[],updatingRecords=[],enteringRecords=[],len=Math.max(from.matched.length,to.matched.length);for(let i=0;i<len;i++){const recordFrom=from.matched[i];recordFrom&&(to.matched.find((record=>isSameRouteRecord(record,recordFrom)))?updatingRecords.push(recordFrom):leavingRecords.push(recordFrom));const recordTo=to.matched[i];recordTo&&(from.matched.find((record=>isSameRouteRecord(record,recordTo)))||enteringRecords.push(recordTo))}return[leavingRecords,updatingRecords,enteringRecords]}(to,from);guards=extractComponentsGuards(leavingRecords.reverse(),"beforeRouteLeave",to,from);for(const record of leavingRecords)record.leaveGuards.forEach((guard=>{guards.push(guardToPromiseFn(guard,to,from))}));const canceledNavigationCheck=checkCanceledNavigationAndReject.bind(null,to,from);return guards.push(canceledNavigationCheck),runGuardQueue(guards).then((()=>{guards=[];for(const guard of beforeGuards.list())guards.push(guardToPromiseFn(guard,to,from));return guards.push(canceledNavigationCheck),runGuardQueue(guards)})).then((()=>{guards=extractComponentsGuards(updatingRecords,"beforeRouteUpdate",to,from);for(const record of updatingRecords)record.updateGuards.forEach((guard=>{guards.push(guardToPromiseFn(guard,to,from))}));return guards.push(canceledNavigationCheck),runGuardQueue(guards)})).then((()=>{guards=[];for(const record of enteringRecords)if(record.beforeEnter)if(isArray(record.beforeEnter))for(const beforeEnter of record.beforeEnter)guards.push(guardToPromiseFn(beforeEnter,to,from));else guards.push(guardToPromiseFn(record.beforeEnter,to,from));return guards.push(canceledNavigationCheck),runGuardQueue(guards)})).then((()=>(to.matched.forEach((record=>record.enterCallbacks={})),guards=extractComponentsGuards(enteringRecords,"beforeRouteEnter",to,from),guards.push(canceledNavigationCheck),runGuardQueue(guards)))).then((()=>{guards=[];for(const guard of beforeResolveGuards.list())guards.push(guardToPromiseFn(guard,to,from));return guards.push(canceledNavigationCheck),runGuardQueue(guards)})).catch((err=>isNavigationFailure(err,8)?err:Promise.reject(err)))}function triggerAfterEach(to,from,failure){afterGuards.list().forEach((guard=>runWithContext((()=>guard(to,from,failure)))))}function finalizeNavigation(toLocation,from,isPush,replace,data){const error=checkCanceledNavigation(toLocation,from);if(error)return error;const isFirstNavigation=from===START_LOCATION_NORMALIZED,state=isBrowser?history.state:{};isPush&&(replace||isFirstNavigation?routerHistory.replace(toLocation.fullPath,assign({scroll:isFirstNavigation&&state&&state.scroll},data)):routerHistory.push(toLocation.fullPath,data)),currentRoute.value=toLocation,handleScroll(toLocation,from,isPush,isFirstNavigation),markAsReady()}let removeHistoryListener;function setupListeners(){removeHistoryListener||(removeHistoryListener=routerHistory.listen(((to,_from,info)=>{if(!router.listening)return;const toLocation=resolve(to),shouldRedirect=handleRedirectRecord(toLocation);if(shouldRedirect)return void pushWithRedirect(assign(shouldRedirect,{replace:!0}),toLocation).catch(noop);pendingLocation=toLocation;const from=currentRoute.value;var key,scrollPosition;isBrowser&&(key=getScrollKey(from.fullPath,info.delta),scrollPosition=computeScrollPosition(),scrollPositions.set(key,scrollPosition)),navigate(toLocation,from).catch((error=>isNavigationFailure(error,12)?error:isNavigationFailure(error,2)?(pushWithRedirect(error.to,toLocation).then((failure=>{isNavigationFailure(failure,20)&&!info.delta&&info.type===NavigationType.pop&&routerHistory.go(-1,!1)})).catch(noop),Promise.reject()):(info.delta&&routerHistory.go(-info.delta,!1),triggerError(error,toLocation,from)))).then((failure=>{(failure=failure||finalizeNavigation(toLocation,from,!1))&&(info.delta&&!isNavigationFailure(failure,8)?routerHistory.go(-info.delta,!1):info.type===NavigationType.pop&&isNavigationFailure(failure,20)&&routerHistory.go(-1,!1)),triggerAfterEach(toLocation,from,failure)})).catch(noop)})))}let ready,readyHandlers=useCallbacks(),errorListeners=useCallbacks();function triggerError(error,to,from){markAsReady(error);const list=errorListeners.list();return list.length?list.forEach((handler=>handler(error,to,from))):(warn("uncaught error during route navigation:"),console.error(error)),Promise.reject(error)}function markAsReady(err){return ready||(ready=!err,setupListeners(),readyHandlers.list().forEach((_ref13=>{let[resolve,reject]=_ref13;return err?reject(err):resolve()})),readyHandlers.reset()),err}function handleScroll(to,from,isPush,isFirstNavigation){const{scrollBehavior:scrollBehavior}=options;if(!isBrowser||!scrollBehavior)return Promise.resolve();const scrollPosition=!isPush&&function(key){const scroll=scrollPositions.get(key);return scrollPositions.delete(key),scroll}(getScrollKey(to.fullPath,0))||(isFirstNavigation||!isPush)&&history.state&&history.state.scroll||null;return vue.nextTick().then((()=>scrollBehavior(to,from,scrollPosition))).then((position=>position&&scrollToPosition(position))).catch((err=>triggerError(err,to,from)))}const go=delta=>routerHistory.go(delta);let started;const installedApps=new Set,router={currentRoute:currentRoute,listening:!0,addRoute:function(parentOrRoute,route){let parent,record;return isRouteName(parentOrRoute)?(parent=matcher.getRecordMatcher(parentOrRoute),record=route):record=parentOrRoute,matcher.addRoute(record,parent)},removeRoute:function(name){const recordMatcher=matcher.getRecordMatcher(name);recordMatcher?matcher.removeRoute(recordMatcher):warn('Cannot remove non-existent route "'.concat(String(name),'"'))},hasRoute:function(name){return!!matcher.getRecordMatcher(name)},getRoutes:function(){return matcher.getRoutes().map((routeMatcher=>routeMatcher.record))},resolve:resolve,options:options,push:push,replace:function(to){return push(assign(locationAsObject(to),{replace:!0}))},go:go,back:()=>go(-1),forward:()=>go(1),beforeEach:beforeGuards.add,beforeResolve:beforeResolveGuards.add,afterEach:afterGuards.add,onError:errorListeners.add,isReady:function(){return ready&&currentRoute.value!==START_LOCATION_NORMALIZED?Promise.resolve():new Promise(((resolve,reject)=>{readyHandlers.add([resolve,reject])}))},install(app){const router=this;app.component("RouterLink",RouterLink),app.component("RouterView",RouterView),app.config.globalProperties.$router=router,Object.defineProperty(app.config.globalProperties,"$route",{enumerable:!0,get:()=>vue.unref(currentRoute)}),isBrowser&&!started&&currentRoute.value===START_LOCATION_NORMALIZED&&(started=!0,push(routerHistory.location).catch((err=>{warn("Unexpected error when starting the router:",err)})));const reactiveRoute={};for(const key in START_LOCATION_NORMALIZED)Object.defineProperty(reactiveRoute,key,{get:()=>currentRoute.value[key],enumerable:!0});app.provide(routerKey,router),app.provide(routeLocationKey,vue.shallowReactive(reactiveRoute)),app.provide(routerViewLocationKey,currentRoute);const unmountApp=app.unmount;installedApps.add(app),app.unmount=function(){installedApps.delete(app),installedApps.size<1&&(pendingLocation=START_LOCATION_NORMALIZED,removeHistoryListener&&removeHistoryListener(),removeHistoryListener=null,currentRoute.value=START_LOCATION_NORMALIZED,started=!1,ready=!1),unmountApp()},isBrowser&&addDevtools(app,router,matcher)}};function runGuardQueue(guards){return guards.reduce(((promise,guard)=>promise.then((()=>runWithContext(guard)))),Promise.resolve())}return router},exports.createRouterMatcher=createRouterMatcher,exports.createWebHashHistory=function(base){return(base=location.host?base||location.pathname+location.search:"").includes("#")||(base+="#"),base.endsWith("#/")||base.endsWith("#")||warn('A hash base must end with a "#":\n"'.concat(base,'" should be "').concat(base.replace(/#.*$/,"#"),'".')),createWebHistory(base)},exports.createWebHistory=createWebHistory,exports.isNavigationFailure=isNavigationFailure,exports.loadRouteLocation=function(route){return route.matched.every((record=>record.redirect))?Promise.reject(new Error("Cannot load a route that redirects.")):Promise.all(route.matched.map((record=>record.components&&Promise.all(Object.keys(record.components).reduce(((promises,name)=>{const rawComponent=record.components[name];return"function"!=typeof rawComponent||"displayName"in rawComponent||promises.push(rawComponent().then((resolved=>{if(!resolved)return Promise.reject(new Error("Couldn't resolve component \"".concat(name,'" at "').concat(record.path,'". Ensure you passed a function that returns a promise.')));const resolvedComponent=isESModule(resolved)?resolved.default:resolved;record.components[name]=resolvedComponent}))),promises}),[]))))).then((()=>route))},exports.matchedRouteKey=matchedRouteKey,exports.onBeforeRouteLeave=function(leaveGuard){if(!vue.getCurrentInstance())return void warn("getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function");const activeRecord=vue.inject(matchedRouteKey,{}).value;activeRecord?registerGuard(activeRecord,"leaveGuards",leaveGuard):warn("No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?")},exports.onBeforeRouteUpdate=function(updateGuard){if(!vue.getCurrentInstance())return void warn("getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function");const activeRecord=vue.inject(matchedRouteKey,{}).value;activeRecord?registerGuard(activeRecord,"updateGuards",updateGuard):warn("No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?")},exports.parseQuery=parseQuery,exports.routeLocationKey=routeLocationKey,exports.routerKey=routerKey,exports.routerViewLocationKey=routerViewLocationKey,exports.stringifyQuery=stringifyQuery,exports.useLink=useLink,exports.useRoute=function(){return vue.inject(routeLocationKey)},exports.useRouter=function(){return vue.inject(routerKey)},exports.viewDepthKey=viewDepthKey,exports}({},(_vue=(obj=_vue)&&obj.__esModule?obj:{default:obj}).default),_default=VueRouter;return _exports.default=_default,_exports.default}));

//# sourceMappingURL=vue3-router.min.js.map